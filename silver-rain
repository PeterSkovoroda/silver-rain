#!/usr/bin/env python3

import gi
gi.require_version("Gst", "1.0")
gi.require_version("Gtk", "3.0")
from gi.repository import Gst, Gtk, GObject, Gdk
from gi.repository import GdkPixbuf
from gi.repository import Notify

import signal
import logging
import datetime
import os

import xml.etree.ElementTree as etree

# Stream uri
stream_url_list = [
        'http://icecast.silver.cdnvideo.ru/silver',
        'http://radiosilver.corbina.net:8000/silver128.mp3',
        'http://radiosilver.corbina.net:8000/silver48.mp3'
        ]
broadcast_url = stream_url_list[0]

# Schedule XML file
recordings_folder = "/home/petr/SilverRain/"
sched_file = "sched.xml"
IMG_LOCATION = "imgs/"

# Own style
css_path = 'silver-rain.css'
#style_provider = Gtk.CssProvider()
#css = open(css_path, 'rb')
#css_data = css.read()
#css.close()
#style_provider.load_from_data(css_data)
#Gtk.StyleContext.add_provider_for_screen (Gdk.Screen.get_default(), style_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

# Colors
# * Silver red - #FF4545
# * Reddit red - #FF4C4C
# * Kinda yellow - beige
SCHEDULE_BG_COLORS      = ["white", "#FFD9D9"]
SCHEDULE_FONT_COLORS    = ["black", "black"]
CHILD_BG_COLORS         = ["gray93", "#FFEBEB"]
CHILD_FONT_COLORS       = ["black", "black"]

class SilverPlayer():
    """ Gstreamer container for playing network audio stream
        sophttpsrc -> decodebin -> audioconvert -> volume -> autoaudiosink"""
    def __init__(self):
        self.__playing__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__playing__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def playback_get(self):
        """ Return playback status """
        return self.__playing__

    def playback_toggle(self):
        """ Playback trigger """
        self.__playing__ = not self.__playing__
        if self.__playing__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def volume_get(self):
        """ Return volume """
        value = int(self.pipeline.get_by_name('volume').get_property('volume') * 100.)
        return value

    def volume_set(self, value):
        """ Set player volume [0-100] """
        self.pipeline.get_by_name('volume').set_property('volume', value / 100.)

    def volume_step(self, increase):
        """ Increase/decrease volume by 5
            Returns new value """
        value = self.pipeline.get_by_name('volume').get_property('volume')
        if increase:
            if value >= 0.95:
                value = 1.
            else:
                value = value + 0.05
        else:
            if value <= 0.05:
                value = 0.
            else:
                value = value - 0.05
        self.pipeline.get_by_name('volume').set_property('volume', value)
        return int(value * 100.)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverPlayer")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc', 'source')
        self.elements["decode"] = Gst.ElementFactory.make('decodebin', 'decode')
        self.elements["convert"] = Gst.ElementFactory.make('audioconvert', 'convert')
        self.elements["volume"] = Gst.ElementFactory.make('volume', 'volume')
        self.elements["sink"] = Gst.ElementFactory.make('autoaudiosink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', broadcast_url)
        self.elements["source"].set_property('is-live', True)
        self.elements["volume"].set_property('volume', 1.)

        # Link elements
        def pad_added_callback(decode, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["convert"].get_static_pad('sink'))

        self.elements["decode"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"], self.elements["decode"]) or \
           not Gst.Element.link(self.elements["convert"], self.elements["volume"]) or \
           not Gst.Element.link(self.elements["volume"], self.elements["sink"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(), err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
            self.playback_toggle()
        else:
            pass

class SilverRecorder():
    """ Gstreamer container for audio recording
        sophttpsrc -> icydemux -> filesink """
    def __init__(self):
        self.__recording__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__recording__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def record_get(self):
        """ Return recorder status """
        return self.__recording__

    def record_toggle(self):
        """ Record trigger """
        self.__recording__ = not self.__recording__
        if self.__recording__:
            filename="Silver_Rain"
            date = datetime.datetime.now()
            file = recordings_folder + date.strftime("%m-%d-%y-%H:%M") + "-" + filename + ".mp3"
            self.pipeline.get_by_name('sink').set_property('location', file)
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverRecorder")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc', 'source')
        self.elements["demux"] = Gst.ElementFactory.make('icydemux', 'demux')
        self.elements["sink"] = Gst.ElementFactory.make('filesink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', broadcast_url)
        self.elements["source"].set_property('is-live', True)
        self.elements["sink"].set_property('location', "file.mp3")

        # Link elements
        def pad_added_callback(demux, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["sink"].get_static_pad('sink'))

        self.elements["demux"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"], self.elements["demux"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(), err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

class SilverGUI(Gtk.Window):
    """ GUI """
    def __init__(self, player, recorder):
        self.__playing__ = False
        self.__player__ = player
        self.__recording__ = False
        self.__recorder__ = recorder
        self.__volume__ = 100
        self.__muted__ = 0

        self.__main_window__ = True
        self.__about_window__ = False
        self.__prefs_window__ = False

        self.create_main_window()
        self.create_status_icon()
#TODO   self.create_notification()
        self.notification = Notify.Notification.new("Header", "Body", "image")

### Main Window
    def create_main_window(self):
        """ Init top window """
        Gtk.Window.__init__(self, title="Silver Rain")
        self.set_border_width(0)
        self.set_default_size(650, 450)
        self.connect("delete-event", self.mw_on_delete_event)
        # Schedule
        self.schedule = self.schedule_get()
        self.week_filter = datetime.date.today().strftime("%A")

        # Main box
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        ## Menubar
        menubar = self.create_menubar()
        vbox.pack_start(menubar, False, False, 0)
        sep = Gtk.Separator()
        vbox.pack_start(sep, False, False, 0)
        ## Schedule tree
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_min_content_height(100)
        tree = self.create_tree()
        scrolled_window.add(tree)
        vbox.pack_start(scrolled_window, True, True, 0)
        ## Selection
        selection = self.create_selection()
        vbox.pack_start(selection, False, False, 0)
        # Controls
        control_panel = self.create_control_panel()
        vbox.pack_end(control_panel, False, False, 0)

        self.add(vbox)
        self.show_all()

    def mw_on_delete_event(self, window, event):
        """ Hide top window instead of destroying it """
        self.__main_window__ = False
        window.hide()
        return True

### Schedule
    def schedule_get(self):
        """ Schedule list:
            0   Weekday             str
            1   IsParent            bool
            2   StartTime           str
            3   EndTime             str
            4   Title               str
            5   Host                str
            6   BackgroundColor     str
            7   FontColor           str
            8   Icon                pixbuf
        """
        sched_list = []
        bg_dark = False
        # Parse XML file
        tree = etree.parse(sched_file)
        root = tree.getroot()

        def parse_obj(obj):
            start = obj.find('start').text
            end = obj.find('end').text
            title = obj.find('title').text
            host = obj.find('host').text
            icon = obj.find('icon').text
            if icon == None:
                icon = "img000.png"
            return start, end, title, host, icon

        for obj in root:
            weekday = obj.attrib['day']
            start, end, title, host, icon = parse_obj(obj)
            icon = IMG_LOCATION + icon
            #picon = GdkPixbuf.Pixbuf.new_from_file_at_scale(icon, 75, 75, True)
            picon = GdkPixbuf.Pixbuf.new_from_file(icon)
            bg_color = SCHEDULE_BG_COLORS[bg_dark]
            fg_color = SCHEDULE_FONT_COLORS[bg_dark]
            bg_dark = not bg_dark
            sched_list.append([weekday, True, start, end, title, host, bg_color, fg_color, picon])
            # Parse children
            ch_dark = bg_dark
            for child in obj.findall('child'):
                start, end, title, host, icon = parse_obj(child)
                icon = IMG_LOCATION + icon
                picon = GdkPixbuf.Pixbuf.new_from_file_at_scale(icon, 60, 60, True)
                bg_color = CHILD_BG_COLORS[ch_dark]
                fg_color = CHILD_FONT_COLORS[ch_dark]
                sched_list.append([weekday, False, start, end, title, host, bg_color, fg_color, picon])
                ch_dark = not ch_dark
        return sched_list

### Selection
    def create_selection(self):
        """ Create selection buttons """
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        for day in ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]:
            button = Gtk.ToggleButton(day)
            button.connect("toggled", self.selection_on_clicked)
            hbox.pack_start(button, True, True, 0)
        return hbox

    def selection_on_clicked(self, button):
        """ Filter Treeview by selected weekday """
        self.week_filter = button.get_label()
        self.filter.refilter()

### Schedule tree
    def create_tree(self):
        """ Create schedule tree """
        store = Gtk.TreeStore(str, bool, str, str, str, str, str, GdkPixbuf.Pixbuf)
        """ Store:
            0   Weekday             str
            1   IsParent            bool
            2   Time                str
            3   Title               str
            4   Host                str
            5   BackgroundColor     str
            6   FontColor           str
            7   Icon                pixbuf
        """
        self.filter = store.filter_new()
        self.filter.set_visible_func(self.sched_filter_func)

        it = None
        for item in self.schedule:
            if item[1]:
                it = store.append(None,[item[0], item[1],
                    item[2] + " - " + item[3],
                    item[4], item[5], item[6], item[7], item[8]])
            else:
                store.append(it, [item[0], item[1],
                    item[2] + " - " + item[3],
                    item[4], item[5], item[6], item[7], item[8]])

        sched_tree = Gtk.TreeView.new_with_model(self.filter)
        sched_tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)

        # Icon
        renderer = Gtk.CellRendererPixbuf()
        column = Gtk.TreeViewColumn(" ", renderer, pixbuf=7)
        renderer.set_alignment(1, 0.5)
        sched_tree.append_column(column)

        renderer = Gtk.CellRendererText()
        renderer.set_padding(10, 0)
        renderer.set_property('font', "11")
        renderer.set_alignment(0.5, 0.5)
        # Time
        column = Gtk.TreeViewColumn("Time", renderer, text=2, background=5, foreground=6)
        column.set_alignment(0.5)
        column.set_min_width(10)
        sched_tree.append_column(column)
        # Title
        renderer.set_alignment(0, 0.5)
        column = Gtk.TreeViewColumn("Title", renderer, text=3, background=5, foreground=6)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        # Host
        column = Gtk.TreeViewColumn("Host", renderer, text=4, background=5, foreground=6)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        return sched_tree

    def sched_filter_func(self, model, iter, data):
        """ Filter by weekday """
        return model[iter][0] == self.week_filter

### Menubar
    def create_menubar(self):
        """ Menu bar """
        agr = Gtk.AccelGroup()
        self.add_accel_group(agr)
        menubar = Gtk.MenuBar()
        # Music
        music_menu = Gtk.Menu()
        music = Gtk.MenuItem("Music")
        music.set_submenu(music_menu)
        ## Play
        self.menubar_play = self.create_menuitem("Play", "media-playback-start")
        self.menubar_play.set_size_request(90, -1)
        self.menubar_play.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F6")
        self.menubar_play.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop
        self.menubar_stop = self.create_menuitem("Stop", "media-playback-stop")
        self.menubar_stop.set_sensitive(False)
        self.menubar_stop.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F7")
        self.menubar_stop.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Record
        self.menubar_record = self.create_menuitem("Record", "media-record")
        self.menubar_record.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F8")
        self.menubar_record.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop recording
        self.menubar_stop_recording = self.create_menuitem("Stop recording", "media-playback-stop")
        self.menubar_stop_recording.set_sensitive(False)
        self.menubar_stop_recording.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F9")
        self.menubar_stop_recording.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Mute
        self.menubar_mute = Gtk.CheckMenuItem("Mute")
        self.menubar_mute.connect("toggled", self.mute_toggle)
        key, mod = Gtk.accelerator_parse("<Control>M")
        self.menubar_mute.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Preferences
        prefs = self.create_menuitem("Preferences", "gtk-preferences")
        prefs.connect("activate", self.create_prefs_window)
        key, mod = Gtk.accelerator_parse("<Control>P")
        prefs.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        key, mod = Gtk.accelerator_parse("<Control>Q")
        quit.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)

        ## Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [self.menubar_play, self.menubar_stop,
                     self.menubar_record, self.menubar_stop_recording,
                     sep[0], self.menubar_mute, sep[1], prefs, sep[2], quit]:
            music_menu.append(item)

        # Help
        help_menu = Gtk.Menu()
        help = Gtk.MenuItem("Help")
        help.set_submenu(help_menu)
        ## About
        about = self.create_menuitem("About", "gtk-about")
        about.set_size_request(90, -1)
        about.connect("activate", self.create_about_window)
        key, mod = Gtk.accelerator_parse("F1")
        about.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        help_menu.append(about)

        menubar.append(music)
        menubar.append(help)

        return menubar

    def menubar_mute_toggle(self):
        if self.__muted__:
            self.menubar_mute.set_active(False)
        else:
            self.menubar_mute.set_active(True)

### Toolbar
    def create_control_panel(self):
        """ Playback control buttons """
        toolbar = Gtk.Toolbar()
        toolbar.set_orientation(Gtk.Orientation.HORIZONTAL)
        toolbar.set_style(Gtk.ToolbarStyle.ICONS)

        control_panel = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        control_panel.set_spacing(6)
        control_panel.set_border_width(6)
        ## Playback Button
        icon = self.get_playback_label()[1]
        self.playback_button = self.create_toolbutton(icon)
        self.playback_button.connect("clicked", self.playback_toggle)
        ## Record Button
        icon = self.get_record_label()[1]
        self.record_button = self.create_toolbutton(icon)
        self.record_button.connect("clicked", self.record_toggle)
        self.record_button.focus_on_click = True
        ## Text
        self.text = Gtk.Label("<span size='12000'><b>Currently Playing</b></span>")
        self.text.set_use_markup(True)
        self.text.set_selectable(True)
        self.text.set_yalign(0.45)
        ## Mute Button
        icon = self.get_volume_icon()
        self.mute_button = self.create_toolbutton(icon)
        self.mute_button.connect("clicked", self.cp_on_mute)

        toolbar.insert(self.playback_button, 0)
        toolbar.insert(self.record_button, 1)
        ## Volume scale
        ad = Gtk.Adjustment(value=self.__volume__, lower=0, upper=100, step_increment=5, page_increment=10, page_size=0)
        self.volume = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=ad)
        self.volume.set_property('draw-value', False)
        self.volume.connect("value-changed", self.cp_on_volume_changed)
        self.volume.set_size_request(80, 0)

        control_panel.pack_start(toolbar, False, False, 0)
        control_panel.pack_start(self.text, True, False, 0)
        control_panel.pack_end(self.volume, False, False, 0)
        control_panel.pack_end(self.mute_button, False, False, 0)

        return control_panel

    def cp_on_volume_changed(self, scale):
        self.__volume__ = scale.get_value()
        if not self.__muted__ and self.__volume__ == 0:
            self.menubar_mute_toggle()
        if self.__muted__ and self.__volume__ > 0:
            self.__muted__ = self.__volume__
            self.menubar_mute_toggle()
        self.__player__.volume_set(self.__volume__)

    def cp_on_mute(self, arg):
        self.menubar_mute_toggle()

    def create_toolbutton(self, icon):
        ## Playback Button
        button = Gtk.ToolButton()
        button.set_icon_name(icon)
        button.focus_on_click = False
        return button

### Popup menu
    def create_popup_menu(self, icon, button, time):
        """ Show menu on right click """
        self.popup_menu = Gtk.Menu()
        # Playback
        text, icon = self.get_playback_label()
        play = self.create_menuitem(text, icon)
        play.connect("activate", self.playback_toggle)
        play.set_size_request(100, -1)
        # Record
        text, icon = self.get_record_label()
        record = self.create_menuitem(text, icon)
        record.connect("activate", self.record_toggle)
        # Mute
        mute = Gtk.CheckMenuItem("Mute")
        if self.__muted__:
            mute.set_active(True)
        mute.connect("toggled", self.popup_mute)
        # Preferences
        preferences = self.create_menuitem("Preferences", "gtk-preferences")
        preferences.connect("activate", self.create_prefs_window)
        # Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        # Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [play, record, sep[0], mute, sep[1], preferences, sep[2], quit]:
            self.popup_menu.append(item)
        self.popup_menu.show_all()

        def pos_func(menu, x, y, icon):
            return (Gtk.StatusIcon.position_menu(menu, x, y, icon))
        self.popup_menu.popup(None, None, pos_func, self.status_icon, button, time)

    def popup_mute(self, arg):
        self.menubar_mute_toggle()

### Status Icon
    def create_status_icon(self):
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_from_icon_name("media-tape")
        self.status_icon.connect("activate", self.status_icon_on_activate)
        self.status_icon.connect("popup-menu", self.create_popup_menu)
        self.status_icon.connect("scroll-event", self.status_icon_on_scroll)

    def status_icon_on_activate(self, icon):
        """ Show/hide main window on left click """
        self.__main_window__ = not self.__main_window__
        if self.__main_window__:
            self.show()
        else:
            self.hide()

    def status_icon_on_scroll(self, icon, data):
        """ Change volume by scrolling on status icon """
        direction = data.direction
        if direction == Gdk.ScrollDirection.UP:
            self.__volume__ = self.__player__.volume_step(True)
            if self.__muted__:
                self.menubar_mute_toggle()
        elif direction == Gdk.ScrollDirection.DOWN:
            self.__volume__ = self.__player__.volume_step(False)
            if self.__volume__ == 0:
                self.menubar_mute_toggle()
        self.volume.set_value(self.__volume__)

### Preferences window
    def create_prefs_window(self, something):
        pass

### About window
    def create_about_window(self, icon):
        def uri_open(uri):
            Popen(['xdg-open', uri], stdout=PIPE)
        about = Gtk.AboutDialog()
        about.set_name("Silver Rain")
        about.set_version("0.1")
        about.set_copyright('Copyright \xa9 2015 Petr Skovoroda')
        about.set_comments('Silver Rain radio player')
        about.set_website('http://silver.ru')
        about.run()
        about.destroy()

### Common
    def create_menuitem(self, text, icon):
        """ Create Menu item with icon """
        icontheme = Gtk.IconTheme.get_default()
        icon = icontheme.load_icon(icon, 16, 0)
        img = Gtk.Image()
        img.set_from_pixbuf(icon)

        menuitem = Gtk.ImageMenuItem()
        menuitem.set_image(img)
        menuitem.set_label(text)
        return menuitem

    def playback_toggle(self, button):
        self.__playing__ = not self.__playing__
        self.playback_button.set_icon_name(self.get_playback_label()[1])

        if self.__playing__:
            self.menubar_play.set_sensitive(False)
            self.menubar_stop.set_sensitive(True)
        else:
            self.menubar_play.set_sensitive(True)
            self.menubar_stop.set_sensitive(False)

        self.__player__.playback_toggle()
        self.show_notification()

    def record_toggle(self, button):
        self.__recording__ = not self.__recording__
        self.record_button.set_icon_name(self.get_record_label()[1])
        if self.__recording__:
            self.menubar_record.set_sensitive(False)
            self.menubar_stop_recording.set_sensitive(True)
        else:
            self.menubar_record.set_sensitive(True)
            self.menubar_stop_recording.set_sensitive(False)

        self.__recorder__.record_toggle()

    def mute_toggle(self, button, val=0):
        if self.__muted__:
            self.__volume__ = self.__muted__
            self.__muted__ = 0
        else:
            self.__muted__ = self.__volume__ or 5
            self.__volume__ = 0

        self.__player__.volume_set(self.__volume__)
        self.mute_button.set_icon_name(self.get_volume_icon())
        self.volume.set_value(self.__volume__)

    def get_playback_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__playing__:
            label = "Play"
            icon = "media-playback-start"
        else:
            label = "Stop"
            icon = "media-playback-stop"
        return label, icon

    def get_record_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__recording__:
            label = "Record"
            icon = "media-record"
        else:
            label = "Stop recording"
            icon = "media-playback-stop"
        return label, icon

    def get_volume_icon(self):
        """ Return label and icon for Playback menu/button """
        if self.__muted__:
            icon = "audio-volume-muted"
        else:
            icon = "audio-volume-high"
        return icon

    def show_notification(self):
        if self.__playing__:
            text = "Playing"
            body = "Silver Rain"
            img = "notification-audio-play"
        else:
            text = "Stopped"
            body = "Silver Rain"
            img = "notification-audio-stop"
        self.notification.update(text, body, img)
        self.notification.show()

GObject.threads_init()
Gst.init(None)
signal.signal(signal.SIGINT, signal.SIG_DFL)
Notify.init("Silver Rain")

player = SilverPlayer()
recorder = SilverRecorder()
silver = SilverGUI(player, recorder)

# Create directory for recordings if it does not exist
if not os.path.exists(recordings_folder):
    os.makedirs(recordings_folder)

Gtk.main()
Notify.uninit()
player.clean()
recorder.clean()
