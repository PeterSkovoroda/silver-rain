#!/usr/bin/env python3

import gi
gi.require_version("Gst", "1.0")
gi.require_version("Gtk", "3.0")
from gi.repository import Gst, Gtk, GObject, Gdk, GdkPixbuf, Notify

import json
import logging
import os
import re
import signal
import subprocess
import threading
import urllib.request

from collections import deque
from datetime import date
from datetime import datetime
from datetime import timedelta

try:
    from lxml import etree
except ImportError as err:
    import xml.etree.ElementTree as etree

########################################################################
# Default values
#TODO: should be configured in settings

# Stream
STREAM_URL_LIST = [
        'http://icecast.silver.cdnvideo.ru/silver',
        'http://radiosilver.corbina.net:8000/silver128.mp3',
        'http://radiosilver.corbina.net:8000/silver48.mp3'
        ]
SILVER_STREAM_URL = STREAM_URL_LIST[0]

# System files
APP_DIR = ".silver/"
IMG_DIR = APP_DIR + "imgs/"
RECS_DIR = os.getenv("HOME") + "/SilverRain/"
SILVER_URL = "http://silver.ru"
SCHED_FILE = APP_DIR + "sched.dump"
SCHED_URL = "http://silver.ru/programms/"

# Own style
CSS_PATH = 'silver-rain.css'
#style_provider = Gtk.CssProvider()
#css = open(CSS_PATH, 'rb')
#css_data = css.read()
#css.close()
#style_provider.load_from_data(css_data)
#Gtk.StyleContext.add_provider_for_screen (Gdk.Screen.get_default(),
#                                       style_provider,
#                                       Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

# Colors
# * Silver red - #FF4545
# * Reddit red - #FF4C4C
# * Silver light red - #FFD9D9
# * Kinda yellow - beige
SCHED_BG_COLORS         = ["white", "gray95"]
SCHED_FG_COLORS         = ["black", "black"]
SCHED_CHILD_BG_COLORS   = ["gray90", "#FFEBEB"]
SCHED_CHILD_FG_COLORS   = ["black", "black"]
SCHED_CURRENT_BG_COLOR  = "#FF4545"
SCHED_CURRENT_FG_COLOR  = "white"
# Fonts
SCHED_FONT              = "Ubuntu 11"
SCHED_CURRENT_FONT      = "Ubuntu bold 11"

# If one day I'll have to translate this shit
WEEKDAY_LIST = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday', 'Sunday']

########################################################################
# GStreamer classes
## Player
class SilverPlayer():
    """ Gstreamer container for playing network audio stream
        sophttpsrc -> decodebin -> audioconvert -> volume -> autoaudiosink"""
    def __init__(self):
        self.__playing__ = False
        self.create_pipeline()

    def clean(self):
        """ Unref pipeline """
        self.__playing__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def playback_toggle(self):
        """ Playback trigger """
        self.__playing__ = not self.__playing__
        if self.__playing__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY instead of STOP to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def volume_get(self):
        """ Return volume status """
        value = int(
            self.pipeline.get_by_name('volume').get_property('volume') * 100.)
        return value

    def volume_set(self, value):
        """ Set player volume [0-100] """
        self.pipeline.get_by_name('volume').set_property('volume',
                                                         value / 100.)

    def volume_step(self, increase):
        """ Increase/decrease volume by 5
            Return new value """
        value = self.pipeline.get_by_name('volume').get_property('volume')
        if increase:
            if value >= 0.95:
                value = 1.
            else:
                value = value + 0.05
        else:
            if value <= 0.05:
                value = 0.
            else:
                value = value - 0.05
        self.pipeline.get_by_name('volume').set_property('volume', value)
        return int(value * 100.)

    def create_pipeline(self):
        self.elements = dict()
        self.pipeline = Gst.Pipeline.new("SilverPlayer")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)
        # Create GStream elements
        try:
            self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                              'source')
            self.elements["decode"] = Gst.ElementFactory.make('decodebin',
                                                              'decode')
            self.elements["convert"] = Gst.ElementFactory.make('audioconvert',
                                                               'convert')
            self.elements["volume"] = Gst.ElementFactory.make('volume',
                                                              'volume')
            self.elements["sink"] = Gst.ElementFactory.make('autoaudiosink',
                                                            'sink')
        except Gst.ElementNotFoundError:
            logging.error("Couldn't find elements", "Check if packages ",
                          "'GStreamer Good Plugins 1.0' ",
                          "'GStreamer Base Plugins 1.0' ",
                          "are installed")
            exit(-1)

        for key in self.elements:
            if not self.elements[key]:
                logging.error("Couldn't create element:", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["volume"].set_property('volume', 1.)

        # Link elements
        def pad_added_callback(decode, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["convert"].get_static_pad('sink'))

        self.elements["decode"].connect('pad-added', pad_added_callback)

        if (not Gst.Element.link(self.elements["source"],
                                 self.elements["decode"]) or
            not Gst.Element.link(self.elements["convert"],
                                 self.elements["volume"]) or
            not Gst.Element.link(self.elements["volume"],
                                 self.elements["sink"])):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
#TODO: What should I do?..
            # Try again
            self.__playing__ = False
            self.pipeline.set_state(Gst.State.READY)
            self.playback_toggle()
        else:
            pass

## Recorder
class SilverRecorder():
#TODO: Merge souphttpsrc container with player
    """ Gstreamer container for audio recording
        souphttpsrc -> icydemux -> filesink """
    def __init__(self):
        self.__recording__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__recording__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def record_get(self):
        """ Return recorder status """
        return self.__recording__

    def record_toggle(self, name):
        """ Record trigger """
        self.__recording__ = not self.__recording__
        if self.__recording__:
            file = RECS_DIR + datetime.now().strftime("%m-%d-%y-%H:%M") + \
                   "-" + name + ".mp3"
            self.pipeline.get_by_name('sink').set_property('location', file)
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def create_pipeline(self):
        self.elements = dict()
        self.pipeline = Gst.Pipeline.new("SilverRecorder")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        try:
            self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                              'source')
            self.elements["demux"] = Gst.ElementFactory.make('icydemux',
                                                             'demux')
            self.elements["sink"] = Gst.ElementFactory.make('filesink',
                                                            'sink')
        except Gst.ElementNotFoundError:
            logging.error("Couldn't find elements", "Check if packages ",
                          "'GStreamer Good Plugins 1.0' ",
                          "'GStreamer Base Plugins 1.0' ",
                          "are installed")
            exit(-1)

        for key in self.elements:
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["sink"].set_property('location', "file.mp3")

        # Link elements
        def pad_added_callback(demux, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["sink"].get_static_pad('sink'))

        self.elements["demux"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"],
                                self.elements["demux"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
#TODO:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

########################################################################
# Schedule
class SilverSchedule():
    """
        __sched_week__      - full schedule
        __sched_day__       - daily agenda
        __event__           - currently playing
        __event_pos__       - event position

        Schedule list[weekday(0-6)]:
            0   Weekday             str
            1   IsParent            bool
            2   Time  (HH:MM-HH:MM) str
            3   Title               str
            4   URL                 str
            5   Host                [str]
            6   Icon                str
            7   start (seconds)     float
            8   end   (seconds)     float
            9   Icon URL            str
    """
    def __init__(self):
        #self.__sched_week__ = [ [] for x in range(7) ]
        self.__sched_week__ = [ [] for x in range(7) ]
        self.__sched_day__ = deque()
        self.__event_pos__ = -1
        # Retrieve schedule
        if os.path.exists(SCHED_FILE):
            # Read from file
            self.sched_get_from_file()
        else:
            # Load from website
            self.sched_get_from_html()
        # Generate schedule for today
        self.sched_gen_daily_agenda()
        # Update current event
        self.sched_update_current()

    def set_timer(self, timer):
#TODO:  Need something better
        self.__timer__ = timer

    def update_schedule(self):
        """ Force downloading sched from internet """
        # Backup
        sched_week_bak = self.__sched_week__
        sched_day_bak = self.__sched_day__
        # Clear
        self.__sched_week__ = [ [] for x in range(7) ]
        self.__sched_day__ = deque()
        if not self.sched_get_from_html():
#TODO:      Raise alert
            logging.warning("Couldn't update")
            self.__sched_week__ = sched_week_bak
            self.__sched_day__ = sched_day_bak
        else:
            self.sched_gen_daily_agenda()
            self.sched_update_current()
            self.__timer__.reset()

    def fill_tree_strore(self, store):
        """ Fill TreeStore object """
        it = None

        for x in range(7):
            bg_dark = False
            ch_dark = bg_dark

            for item in self.__sched_week__[x]:
                host = '\n'.join(item["host"])
                font = SCHED_FONT
                # Download icon if it doesn't exist
                if not os.path.exists(item["icon"]):
                    urllib.request.urlretrieve(item["icon_url"], item["icon"])
                if item["is_main"]:
                    # Main event
                    bg_color = SCHED_BG_COLORS[bg_dark]
                    fg_color = SCHED_FG_COLORS[bg_dark]
                    # Get pixbuf
                    icon = GdkPixbuf.Pixbuf.new_from_file(item["icon"])
                    # Insert item
                    it = store.append(None, [item["weekday"], item["is_main"],
                                             item["time"], item["title"],
                                             item["url"], host, icon,
                                             bg_color, fg_color, font])
                    # Alternate row color
                    ch_dark = bg_dark
                    bg_dark = not bg_dark
                else:
                    # Child event
                    bg_color = SCHED_CHILD_BG_COLORS[ch_dark]
                    fg_color = SCHED_CHILD_FG_COLORS[ch_dark]
                    # Get pixbuf
                    icon = GdkPixbuf.Pixbuf.new_from_file_at_scale(
                                                            item["icon"],
                                                            60, 60, True)
                    # Insert item
                    store.append(it, [item["weekday"], item["is_main"],
                                 item["time"], item["title"], item["url"],
                                 host, icon, bg_color, fg_color, font])
                    # Alternate row color
                    ch_dark = not ch_dark

    def get_event_title(self):
        """ Return title of current event """
        return self.__event__["title"]

    def get_event_icon(self):
        """ Return pixbuf """
        # Download icon if it doesn't exist
        if not os.path.exists(self.__event__["icon"]):
            urllib.request.urlretrieve(self.__event__["icon_url"], self.__event__["icon"])
        return GdkPixbuf.Pixbuf.new_from_file(self.__event__["icon"])

    def get_event(self):
        """ Return current event """
        return self.__event__

    def get_event_position(self):
        """ Return current event """
        return self.__event_pos__

    def sched_gen_daily_agenda(self):
        """ Create a list of main events for today """
        self.__event_pos__ = -1
        today = datetime.now()
        now = timedelta(hours=today.hour, minutes=today.minute,
                        seconds=today.second).total_seconds()
        for item in self.__sched_week__[today.weekday()]:
            if not item["is_main"]:
                continue
            elif item["end"] < now:
                # Child or already ended. Skip
                self.__event_pos__ = self.__event_pos__ + 1
                continue
            self.__sched_day__.append(item)

    def sched_update_current(self):
        """ Update current event """
        if not len(self.__sched_day__):
            # It's a new day.
            # It's so mundane. What exciting things will happen today?
            self.sched_gen_daily_agenda()

        item = self.__sched_day__.popleft()
        self.__event__ = item
        self.__event_pos__ = self.__event_pos__ + 1

    def sched_get_from_file(self):
        f = open(SCHED_FILE, "r")
        self.__sched_week__ = json.load(f)
        f.close()

    def sched_write_to_file(self):
        f = open(SCHED_FILE, 'w')
        json.dump(self.__sched_week__, f)
        f.close()

    def sched_get_from_html(self):
        # Default event icon
        music_icon_src = ''
        # Weekdays parser
        wd_name_list = {'Вс' : [6], 'Пн' : [0], 'Вт' : [1], 'Ср' : [2],
                        'Чт' : [3], 'Пт' : [4], 'Сб' : [5],
                        'По будням' : list(range(0,5)),
                        'По выходным' : [5, 6]}
        # Download sched
        try:
            xhtml = urllib.request.urlopen(SCHED_URL).read().decode("utf-8")
        except urllib.error.URLError as e:
            logging.error("Connection error:", e)
#TODO       handle error
            return False

        #TODO: come up with something better
        xhtml = re.sub(
                r'^.*<div\ class="program-list">.*?(<tbody>.*?<\/tbody>).*$',
                r'\1', xhtml)
        # Close unclosed img tags /* make it xhtml style */
        xhtml = re.sub(r'(<img.*?"\s*)>', r'\1/>', xhtml)

        root = etree.fromstring(xhtml)
        # Parse xhtml text
        for obj in root:
            if not len(obj[3]):
                # Event happens randomly or never
                continue
            if obj[1][0][0].text == "Музыка":
                # Don't parse music. Just fill spaces with it
                music_icon_src = "http:" + \
                                 obj[0][0][0].attrib['src'].split("?")[0]
                continue
            # Get icon
            icon_src = "http:" + obj[0][0][0].attrib['src'].split("?")[0]
            icon_name = icon_src.split("/")[-1]
            # Get title
            title = obj[1][0][0].text
            # Get program url
            url = SILVER_URL + obj[1][0][0].attrib['href']
            # Get hosts
            host = []
            if len(obj[2]):
                # If hosts exist
                for it in obj[2][0]:
                    host.append(it[0][0].text)
            # Get schedule
            sched = []
            for t in obj[3][0]:
                # Expecting "WD, WD, WD : HH:MM" format
                weekday, time = t.text.split(' : ')
                wd_list = weekday.split(', ')
                start, end = time.split('-')
                for wd in wd_list:
                    #  Weekday number,
                    #  HH:MM,
                    #  start in seconds,
                    #  end in seconds
                    sched.append([wd_name_list[wd], time,
                                  self.sched_parse_time(start),
                                  self.sched_parse_time(end)])
            # Event type
            is_main = False
            if sched[0][3] - sched[0][2] >= 3600:
                # At least 1 hour
                is_main = True
            # Insert
            for it in sched:
                for weekday in it[0]:
                    show = {}
                    show["weekday"] = WEEKDAY_LIST[weekday]
                    show["is_main"] = is_main
                    show["time"] = it[1]
                    show["title"] = title
                    show["url"] = url
                    show["host"] = host
                    show["icon"] = IMG_DIR + icon_name
                    show["start"] = it[2]
                    show["end"] = it[3]
                    show["icon_url"] = icon_src
                    self.__sched_week__[weekday].append(show)

        # Sort schedule by start/parent
        for wd in range(7):
            self.__sched_week__[wd].sort(key = lambda x : (x["start"], -x["is_main"]))

        # Fill spaces with music
        for wd in range(7):
            time = 0.0
            pos = 0
            last = []

            for item in self.__sched_week__[wd]:
                if not item["is_main"]:
                    continue
                if item["start"] > time:
                    # If doesn't start right after the last one
                    show = {}
                    show["is_main"] = True
                    show["title"] = "Музыка"
                    show["url"] = "http://silver.ru/programms/muzyka/"
                    show["host"] = []
                    show["icon"] = IMG_DIR + music_icon_src.split("/")[-1]
                    show["icon_url"] = music_icon_src

                    show["weekday"] = WEEKDAY_LIST[wd]
                    show["time"] = self.sched_str_time(time, item["start"])
                    show["start"] = time
                    show["end"] = item["start"]
                    self.__sched_week__[wd].insert(pos, show)
                    pos = pos + 1
                    print("ADDED MUSIC:", show)
                time = item["end"]
                pos = pos + 1
                last = item
            # Check if last event doesn't go till 24:00
            if last["end"] < 86400.0:
                show = {}
                show["is_main"] = True
                show["title"] = "Музыка"
                show["url"] = "http://silver.ru/programms/muzyka/"
                show["host"] = []
                show["icon"] = IMG_DIR + music_icon_src.split("/")[-1]
                show["icon_url"] = music_icon_src

                show["weekday"] = WEEKDAY_LIST[wd]
                show["time"] = self.sched_str_time(last["end"], 86400.0)
                show["start"] = last["end"]
                show["end"] = 86400.0
                self.__sched_week__[wd].insert(pos, show)
            # Sort by start/parent
            self.__sched_week__[wd].sort(key = lambda x : (x["start"], -x["is_main"]))

        # Save sched to file
        self.sched_write_to_file()

        return True

    def sched_str_time(self, start, end):
        """ Return time in HH:MM-HH:MM """
        s_h, s_m = divmod(int(start), 3600)
        e_h, e_m = divmod(int(end), 3600)
        return "{0:0=2d}:{1:0=2d}-{2:0=2d}:{3:0=2d}".format(s_h, s_m, e_h, e_m)

    def sched_parse_time(self, str):
        """ Return time in seconds """
        try:
            x = datetime.strptime(str, "%H:%M")
        except ValueError:
            # except 24:00
            # Fuck timedelta and python-floating-point-approximation shit
            # Just return the correct value
            return 86400.0
        d = timedelta(hours=x.hour, minutes=x.minute)
        return d.total_seconds()

########################################################################
# GUI
class SilverGUI(Gtk.Window):
    """ GUI """
    def __init__(self, player, recorder, sched):
        self.__playing__ = False
        self.__player__ = player
        self.__recording__ = False
        self.__recorder__ = recorder
        self.__volume__ = 100
        self.__muted__ = 0
        self.cell_bg_old = ''
        self.cell_fg_old = ''

        self.__main_window__ = True
        self.__about_window__ = False
        self.__prefs_window__ = False
        self.__schedule__ = sched
        self.week_filter = date.today().strftime("%A")

        self.create_main_window()
        self.create_status_icon()
        self.notification = Notify.Notification.new("Header", "Body", "image")

### Updater
    def update_status(self):
        """ Update label, bg of current event, show notifications """
        self.tree_mark_current_row()
        self.toolbar_update_label()
        self.show_notification_event()

    def tree_mark_current_row(self):
        pos = self.__schedule__.get_event_position()

        if self.cell_bg_old:
            # Reset previous row
            path = Gtk.TreePath(pos - 1)
            iter = self.sched_model.get_iter(path)
            self.sched_model[iter][7] = self.cell_bg_old
            self.sched_model[iter][8] = self.cell_fg_old
            self.sched_model[iter][9] = SCHED_FONT
            self.cell_bg_old = ''
            self.cell_fg_old = ''

        path = Gtk.TreePath(pos)
        iter = self.sched_model.get_iter(path)
        self.cell_bg_old = self.sched_model[iter][7]
        self.cell_fg_old = self.sched_model[iter][8]
        self.sched_model[iter][7] = SCHED_CURRENT_BG_COLOR
        self.sched_model[iter][8] = SCHED_CURRENT_FG_COLOR
        self.sched_model[iter][9] = SCHED_CURRENT_FONT

        # Scroll to current cell
        self.sched_tree.scroll_to_cell(path, use_align=True, row_align=0.5)

### Main Window
    def create_main_window(self):
        """ Init top window """
        Gtk.Window.__init__(self, title="Silver Rain")
        self.set_border_width(0)
        self.set_default_size(650, 450)
        self.connect("delete-event", self.mw_on_delete_event)

        # Main box
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        ## Menubar
        menubar = self.create_menubar()
        vbox.pack_start(menubar, False, False, 0)
        sep = Gtk.Separator()
        vbox.pack_start(sep, False, False, 0)
        ## Schedule tree
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER,
                                   Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_min_content_height(100)
        self.sched_tree = self.create_tree()
        scrolled_window.add(self.sched_tree)
        vbox.pack_start(scrolled_window, True, True, 0)
        ## Mark current
        self.tree_mark_current_row()
        ## Selection
        selection = self.create_selection()
        vbox.pack_start(selection, False, False, 0)
        # Controls
        control_panel = self.create_control_panel()
        vbox.pack_end(control_panel, False, False, 0)

        self.add(vbox)
        self.show_all()

    def mw_on_delete_event(self, window, event):
        """ Hide top window instead of destroying it """
        self.__main_window__ = False
        window.hide()
        return True

### Menubar
    def create_menubar(self):
        """ Menu bar """
        agr = Gtk.AccelGroup()
        self.add_accel_group(agr)
        menubar = Gtk.MenuBar()
        # Music
        music_menu = Gtk.Menu()
        music = Gtk.MenuItem("Music")
        music.set_submenu(music_menu)
        ## Play
        self.menubar_play = self.create_menuitem("Play",
                                                 "media-playback-start")
        self.menubar_play.set_size_request(90, -1)
        self.menubar_play.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F6")
        self.menubar_play.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop
        self.menubar_stop = self.create_menuitem("Stop", "media-playback-stop")
        self.menubar_stop.set_sensitive(False)
        self.menubar_stop.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F7")
        self.menubar_stop.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Record
        self.menubar_record = self.create_menuitem("Record", "media-record")
        self.menubar_record.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F8")
        self.menubar_record.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop recording
        self.menubar_stop_recording = self.create_menuitem("Stop recording",
                                          "media-playback-stop")
        self.menubar_stop_recording.set_sensitive(False)
        self.menubar_stop_recording.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F9")
        self.menubar_stop_recording.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Mute
        self.menubar_mute = Gtk.CheckMenuItem("Mute")
        self.menubar_mute.connect("toggled", self.mute_toggle)
        key, mod = Gtk.accelerator_parse("<Control>M")
        self.menubar_mute.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Preferences
        prefs = self.create_menuitem("Preferences", "gtk-preferences")
        prefs.connect("activate", self.create_prefs_window)
        key, mod = Gtk.accelerator_parse("<Control>P")
        prefs.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        key, mod = Gtk.accelerator_parse("<Control>Q")
        quit.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [self.menubar_play, self.menubar_stop,
                     self.menubar_record, self.menubar_stop_recording,
                     sep[0], self.menubar_mute, sep[1], prefs, sep[2], quit]:
            music_menu.append(item)

        # Help
        help_menu = Gtk.Menu()
        help = Gtk.MenuItem("Help")
        help.set_submenu(help_menu)
        ## About
        about = self.create_menuitem("About", "gtk-about")
        about.set_size_request(90, -1)
        about.connect("activate", self.create_about_window)
        key, mod = Gtk.accelerator_parse("F1")
        about.add_accelerator("activate", agr, key,
                              mod, Gtk.AccelFlags.VISIBLE)
        help_menu.append(about)

        menubar.append(music)
        menubar.append(help)
        return menubar

    def menubar_mute_toggle(self):
        if self.__muted__:
            self.menubar_mute.set_active(False)
        else:
            self.menubar_mute.set_active(True)

### TreeView
    def create_sched_list_model(self):
        """ Create schedule tree """
        store = Gtk.TreeStore(str,              # Weekday
                              bool,             # IsParent
                              str,              # Time
                              str,              # Title
                              str,              # URL
                              str,              # Host
                              GdkPixbuf.Pixbuf, # Icon
                              str,              # BackgroundColor
                              str,              # FontColor
                              str)              # Font
        self.sched_model = store.filter_new()
        self.sched_model.set_visible_func(self.sched_model_func)
        self.__schedule__.fill_tree_strore(store)

    def sched_model_func(self, model, iter, data):
        """ Filter by weekday """
        return model[iter][0] == self.week_filter

    def sched_on_button_release_event(self, widget, event):
        if not event.button == 3:
            return
        selection = self.sched_tree.get_selection()
        model, iter = selection.get_selected()
        # Create popup menu
        self.sched_popup = Gtk.Menu()
        # Program url
        url = Gtk.MenuItem.new_with_label("Event page")
        url.set_size_request(100, -1)
        event_url = model.get_value(iter, 4)
        url.connect("activate", self.url_open, event_url)
        self.sched_popup.append(url)
        # Record program
        icon = self.get_record_label()[1]
        rec = self.create_menuitem("Record", icon)
        event_time = model.get_value(iter, 2)
        rec.connect("activate", self.sched_rec, event_time)
        self.sched_popup.append(rec)
        self.sched_popup.show_all()
        self.sched_popup.popup(None, None,
                               None, None,
                               event.button, event.time)

    def url_open(self, button, url):
        subprocess.Popen(['xdg-open', url], stdout=subprocess.PIPE)

    def sched_rec(self, button, time):
        pass

    def create_tree(self):
        """ Create schedule tree """
        self.create_sched_list_model()

        sched_tree = Gtk.TreeView.new_with_model(self.sched_model)
        sched_tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)
        sched_tree.connect('button-release-event',
                           self.sched_on_button_release_event)
        # Icon
        renderer = Gtk.CellRendererPixbuf()
        column = Gtk.TreeViewColumn(" ", renderer, pixbuf=6)
        renderer.set_alignment(1, 0.5)
        sched_tree.append_column(column)

        renderer = Gtk.CellRendererText()
        renderer.set_padding(10, 0)
        renderer.set_alignment(0.5, 0.5)
        # Time
        column = Gtk.TreeViewColumn("Time", renderer,
                                    text=2, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(10)
        sched_tree.append_column(column)
        # Title
        renderer.set_alignment(0, 0.5)
        column = Gtk.TreeViewColumn("Title", renderer,
                                    text=3, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        # Host
        column = Gtk.TreeViewColumn("Host", renderer,
                                    text=5, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        return sched_tree

### Selection
    def create_selection(self):
        """ Create selection buttons """
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        for day in WEEKDAY_LIST:
            button = Gtk.ToggleButton(day)
            button.set_size_request(80, 0)
            button.connect("toggled", self.selection_on_clicked)
            hbox.pack_start(button, True, True, 0)
        return hbox

    def selection_on_clicked(self, button):
        """ Filter Treeview by selected weekday """
        self.week_filter = button.get_label()
        self.sched_model.refilter()

### Toolbar
    def create_control_panel(self):
        """ Playback control buttons """
        toolbar = Gtk.Toolbar()
        toolbar.set_orientation(Gtk.Orientation.HORIZONTAL)
        toolbar.set_style(Gtk.ToolbarStyle.ICONS)

        control_panel = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        control_panel.set_spacing(6)
        control_panel.set_border_width(6)
        ## Update schedule Button
        self.sched_refresh = self.create_toolbutton("gtk-refresh")
        self.sched_refresh.connect("clicked", self.tb_sched_update)
        self.sched_refresh.focus_on_click = True
        ## Playback Button
        icon = self.get_playback_label()[1]
        self.playback_button = self.create_toolbutton(icon)
        self.playback_button.connect("clicked", self.playback_toggle)
        ## Record Button
        icon = self.get_record_label()[1]
        self.record_button = self.create_toolbutton(icon)
        self.record_button.connect("clicked", self.record_toggle)
        self.record_button.focus_on_click = True
        ## Label
        self.text = Gtk.Label()
        self.text.set_selectable(True)
        self.text.set_yalign(0.45)
        self.toolbar_update_label()
        ## Mute Button
        icon = self.get_volume_icon()
        self.mute_button = self.create_toolbutton(icon)
        self.mute_button.connect("clicked", self.cp_on_mute)

        toolbar.insert(self.sched_refresh, 0)
        toolbar.insert(self.playback_button, 1)
        toolbar.insert(self.record_button, 2)
        ## Volume scale
        ad = Gtk.Adjustment(value=self.__volume__, lower=0,
                            upper=100, step_increment=5,
                            page_increment=10, page_size=0)
        self.volume = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL,
                                adjustment=ad)
        self.volume.set_property('draw-value', False)
        self.volume.connect("value-changed", self.cp_on_volume_changed)
        self.volume.set_size_request(80, 0)

        control_panel.pack_start(toolbar, False, False, 0)
        control_panel.pack_start(self.text, True, False, 0)
        control_panel.pack_end(self.volume, False, False, 0)
        control_panel.pack_end(self.mute_button, False, False, 0)
        return control_panel

    def toolbar_update_label(self):
        self.text.set_text("<span size='12000'><b>" +
                           self.__schedule__.get_event_title() + "</b></span>")
        self.text.set_use_markup(True)

    def cp_on_volume_changed(self, scale):
        self.__volume__ = scale.get_value()
        if not self.__muted__ and self.__volume__ == 0:
            self.menubar_mute_toggle()
        if self.__muted__ and self.__volume__ > 0:
            self.__muted__ = self.__volume__
            self.menubar_mute_toggle()
        self.__player__.volume_set(self.__volume__)

    def cp_on_mute(self, arg):
        self.menubar_mute_toggle()

    def create_toolbutton(self, icon):
        ## Playback Button
        button = Gtk.ToolButton()
        button.set_icon_name(icon)
        button.focus_on_click = False
        return button

    def tb_sched_update(self, arg):
        self.__schedule__.update_schedule()
        self.create_sched_list_model()
        self.sched_tree.set_model(self.sched_model)
        self.update_status()

### Popup menu
    def create_popup_menu(self, icon, button, time):
        """ Show menu on right click """
        self.popup_menu = Gtk.Menu()
        # Playback
        text, icon = self.get_playback_label()
        play = self.create_menuitem(text, icon)
        play.connect("activate", self.playback_toggle)
        play.set_size_request(100, -1)
        # Record
        text, icon = self.get_record_label()
        record = self.create_menuitem(text, icon)
        record.connect("activate", self.record_toggle)
        # Mute
        mute = Gtk.CheckMenuItem("Mute")
        if self.__muted__:
            mute.set_active(True)
        mute.connect("toggled", self.popup_mute)
        # Preferences
        preferences = self.create_menuitem("Preferences", "gtk-preferences")
        preferences.connect("activate", self.create_prefs_window)
        # Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        # Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [play, record, sep[0], mute,
                     sep[1], preferences, sep[2], quit]:
            self.popup_menu.append(item)
        self.popup_menu.show_all()

        def pos_func(menu, x, y, icon):
            return (Gtk.StatusIcon.position_menu(menu, x, y, icon))
        self.popup_menu.popup(None, None, pos_func,
                              self.status_icon, button, time)

    def popup_mute(self, arg):
        self.menubar_mute_toggle()

### Status Icon
    def create_status_icon(self):
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_from_icon_name("media-tape")
        self.status_icon.connect("activate", self.status_icon_on_activate)
        self.status_icon.connect("popup-menu", self.create_popup_menu)
        self.status_icon.connect("scroll-event", self.status_icon_on_scroll)

    def status_icon_on_activate(self, icon):
        """ Show/hide main window on left click """
        self.__main_window__ = not self.__main_window__
        if self.__main_window__:
            self.show()
        else:
            self.hide()

    def status_icon_on_scroll(self, icon, data):
        """ Change volume by scrolling on status icon """
        direction = data.direction
        if direction == Gdk.ScrollDirection.UP:
            self.__volume__ = self.__player__.volume_step(True)
            if self.__muted__:
                self.menubar_mute_toggle()
        elif direction == Gdk.ScrollDirection.DOWN:
            self.__volume__ = self.__player__.volume_step(False)
            if self.__volume__ == 0:
                self.menubar_mute_toggle()
        self.volume.set_value(self.__volume__)

### Preferences window
    def create_prefs_window(self, something):
        pass

### About window
    def create_about_window(self, icon):
        def uri_open(uri):
            Popen(['xdg-open', uri], stdout=PIPE)
        about = Gtk.AboutDialog()
        about.set_name("Silver Rain")
        about.set_version("0.1")
        about.set_copyright('Copyright \xa9 2015 Petr Skovoroda')
        about.set_comments('Silver Rain radio player')
        about.set_website('http://silver.ru')
        about.run()
        about.destroy()

### Common
    def create_menuitem(self, text, icon):
        """ Create Menu item with icon """
        icontheme = Gtk.IconTheme.get_default()
        icon = icontheme.load_icon(icon, 16, 0)
        img = Gtk.Image()
        img.set_from_pixbuf(icon)

        menuitem = Gtk.ImageMenuItem()
        menuitem.set_image(img)
        menuitem.set_label(text)
        return menuitem

    def playback_toggle(self, button):
        self.__playing__ = not self.__playing__
        self.playback_button.set_icon_name(self.get_playback_label()[1])

        if self.__playing__:
            self.menubar_play.set_sensitive(False)
            self.menubar_stop.set_sensitive(True)
        else:
            self.menubar_play.set_sensitive(True)
            self.menubar_stop.set_sensitive(False)

        self.__player__.playback_toggle()
        self.show_notification_playback()

    def record_toggle(self, button):
        self.__recording__ = not self.__recording__
        self.record_button.set_icon_name(self.get_record_label()[1])
        if self.__recording__:
            self.menubar_record.set_sensitive(False)
            self.menubar_stop_recording.set_sensitive(True)
        else:
            self.menubar_record.set_sensitive(True)
            self.menubar_stop_recording.set_sensitive(False)

        name = self.__schedule__.get_event_title()
        self.__recorder__.record_toggle(name)

    def mute_toggle(self, button, val=0):
        if self.__muted__:
            self.__volume__ = self.__muted__
            self.__muted__ = 0
        else:
            self.__muted__ = self.__volume__ or 5
            self.__volume__ = 0

        self.__player__.volume_set(self.__volume__)
        self.mute_button.set_icon_name(self.get_volume_icon())
        self.volume.set_value(self.__volume__)

    def get_playback_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__playing__:
            label = "Play"
            icon = "media-playback-start"
        else:
            label = "Stop"
            icon = "media-playback-stop"
        return label, icon

    def get_record_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__recording__:
            label = "Record"
            icon = "media-record"
        else:
            label = "Stop recording"
            icon = "media-playback-stop"
        return label, icon

    def get_volume_icon(self):
        """ Return label and icon for Playback menu/button """
        if self.__muted__:
            icon = "audio-volume-muted"
        else:
            icon = "audio-volume-high"
        return icon

    def show_notification_event(self):
        text = "Silver Rain"
        body = self.__schedule__.get_event_title()
        self.notification.set_icon_from_pixbuf(
                self.__schedule__.get_event_icon())
        self.notification.update(text, body)
        self.notification.show()

    def show_notification_playback(self):
        if self.__playing__:
            self.show_notification_event()
        else:
            text = "Silver Rain"
            body = "Stopped"
            img = "notification-audio-stop"
            self.notification.update(text, body, img)
            self.notification.show()

########################################################################
# Threading
class SilverTimer():
    def __init__(self, sched, window):
        self.__sched__ = sched
        self.__window__ = window
        # On event timer
        self.__t_event__ = threading.Timer(0, None)
        self.init_event_timer()
        self.__sched__.set_timer(self)

    def clean(self):
        """ Cancel timer """
        self.__t_event__.cancel()

    def reset(self):
        """ Reset timer """
        self.clean()
        self.init_event_timer()

    def init_event_timer(self):
        """ Raise handler when event ends """
        today = datetime.now()
        now = timedelta(hours=today.hour,
                minutes=today.minute, seconds=today.second).total_seconds()
        event = self.__sched__.get_event()
        timeout = int(event["end"] - now)
        self.__t_event__ = threading.Timer(timeout, self.t_callback_event)
        self.__t_event__.start()

    def t_callback_event(self):
        """ Update schedule """
        self.__sched__.sched_update_current()
        self.__window__.update_status()
        # Init new timer
        self.init_event_timer()

########################################################################
# Boom, baby
GObject.threads_init()
Gst.init(None)
signal.signal(signal.SIGINT, signal.SIG_DFL)
Notify.init("Silver Rain")
# Create directories if they don't exist
for dir in [APP_DIR, IMG_DIR, RECS_DIR]:
    if not os.path.exists(dir):
        os.makedirs(dir)
# Init
silver_player = SilverPlayer()
silver_recorder = SilverRecorder()
silver_schedule = SilverSchedule()
silver_window = SilverGUI(silver_player, silver_recorder, silver_schedule)
silver_timer = SilverTimer(silver_schedule, silver_window)
# Main loop
Gtk.main()
# Cleanup
Notify.uninit()
silver_player.clean()
silver_recorder.clean()
silver_timer.clean()
