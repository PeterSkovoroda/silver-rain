#!/usr/bin/env python3

import gi
gi.require_version("Gst", "1.0")
gi.require_version("Gtk", "3.0")
from gi.repository import Gst, Gtk, GObject, Gdk, GdkPixbuf, Notify

import json
import logging
import os
import re
import requests
import signal
import subprocess
import threading
import urllib.request

from collections import deque
from datetime import date
from datetime import datetime
from datetime import timedelta

try:
    from lxml import etree
except ImportError as err:
    import xml.etree.ElementTree as etree

########################################################################
# Default values
#TODO: should be configured in settings

# Stream
STREAM_URL_LIST = [
        'http://icecast.silver.cdnvideo.ru/silver',
        'http://radiosilver.corbina.net:8000/silver128.mp3',
        'http://radiosilver.corbina.net:8000/silver48.mp3'
        ]
SILVER_STREAM_URL = STREAM_URL_LIST[0]

# System files
APP_DIR = ".silver/"
IMG_DIR = APP_DIR + "imgs/"
RECS_DIR = os.getenv("HOME") + "/SilverRain/"
SILVER_URL = "http://silver.ru"
SCHED_FILE = APP_DIR + "sched.dump"
SCHED_URL = "http://silver.ru/programms/"

# Own style
CSS_PATH = 'silver-rain.css'
style_provider = Gtk.CssProvider()
css = open(CSS_PATH, 'rb')
css_data = css.read()
css.close()
style_provider.load_from_data(css_data)
Gtk.StyleContext.add_provider_for_screen (Gdk.Screen.get_default(),
                                       style_provider,
                                       Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

# Colors
# * Silver red - #FF4545
# * Reddit red - #FF4C4C
# * Silver light red - #FFD9D9
# * Kinda yellow - beige
SCHED_BG_COLORS         = ["white", "gray95"]
SCHED_FG_COLORS         = ["black", "black"]
SCHED_CHILD_BG_COLORS   = ["gray90", "#FFEBEB"]
SCHED_CHILD_FG_COLORS   = ["black", "black"]
SCHED_CURRENT_BG_COLOR  = "#FF4545"
SCHED_CURRENT_FG_COLOR  = "white"
# Fonts
SCHED_FONT              = "Ubuntu 11"
SCHED_CURRENT_FONT      = "Ubuntu bold 11"

# If one day I'll have to translate this shit
WEEKDAY_LIST = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday', 'Sunday']

########################################################################
# GStreamer classes
## Player
class SilverPlayer():
    """ Gstreamer container for playing network audio stream
        sophttpsrc -> decodebin -> audioconvert -> volume -> autoaudiosink"""
    def __init__(self):
        self.__playing__ = False
        self.create_pipeline()

    def clean(self):
        """ Unref pipeline """
        self.__playing__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def playback_toggle(self):
        """ Playback trigger """
        self.__playing__ = not self.__playing__
        if self.__playing__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY instead of STOP to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def volume_get(self):
        """ Return volume status """
        value = int(
            self.pipeline.get_by_name('volume').get_property('volume') * 100.)
        return value

    def volume_set(self, value):
        """ Set player volume [0-100] """
        self.pipeline.get_by_name('volume').set_property('volume',
                                                         value / 100.)

    def volume_step(self, increase):
        """ Increase/decrease volume by 5
            Return new value """
        value = self.pipeline.get_by_name('volume').get_property('volume')
        if increase:
            if value >= 0.95:
                value = 1.
            else:
                value = value + 0.05
        else:
            if value <= 0.05:
                value = 0.
            else:
                value = value - 0.05
        self.pipeline.get_by_name('volume').set_property('volume', value)
        return int(value * 100.)

    def create_pipeline(self):
        self.elements = dict()
        self.pipeline = Gst.Pipeline.new("SilverPlayer")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)
        # Create GStream elements
        try:
            self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                              'source')
            self.elements["decode"] = Gst.ElementFactory.make('decodebin',
                                                              'decode')
            self.elements["convert"] = Gst.ElementFactory.make('audioconvert',
                                                               'convert')
            self.elements["volume"] = Gst.ElementFactory.make('volume',
                                                              'volume')
            self.elements["sink"] = Gst.ElementFactory.make('autoaudiosink',
                                                            'sink')
        except Gst.ElementNotFoundError:
            logging.error("Couldn't find elements", "Check if packages ",
                          "'GStreamer Good Plugins 1.0' ",
                          "'GStreamer Base Plugins 1.0' ",
                          "are installed")
            exit(-1)

        for key in self.elements:
            if not self.elements[key]:
                logging.error("Couldn't create element:", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["volume"].set_property('volume', 1.)

        # Link elements
        def pad_added_callback(decode, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["convert"].get_static_pad('sink'))

        self.elements["decode"].connect('pad-added', pad_added_callback)

        if (not Gst.Element.link(self.elements["source"],
                                 self.elements["decode"]) or
            not Gst.Element.link(self.elements["convert"],
                                 self.elements["volume"]) or
            not Gst.Element.link(self.elements["volume"],
                                 self.elements["sink"])):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
#TODO: What should I do?..
            # Try again
            self.__playing__ = False
            self.pipeline.set_state(Gst.State.READY)
            self.playback_toggle()
        else:
            pass

## Recorder
class SilverRecorder():
#TODO: Merge souphttpsrc container with player
    """ Gstreamer container for audio recording
        souphttpsrc -> icydemux -> filesink """
    def __init__(self):
        self.__recording__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__recording__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def record_get(self):
        """ Return recorder status """
        return self.__recording__

    def record_toggle(self, name):
        """ Record trigger """
        self.__recording__ = not self.__recording__
        if self.__recording__:
            file = RECS_DIR + datetime.now().strftime("%m-%d-%y-%H:%M") + \
                   "-" + name + ".mp3"
            self.pipeline.get_by_name('sink').set_property('location', file)
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def create_pipeline(self):
        self.elements = dict()
        self.pipeline = Gst.Pipeline.new("SilverRecorder")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        try:
            self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                              'source')
            self.elements["demux"] = Gst.ElementFactory.make('icydemux',
                                                             'demux')
            self.elements["sink"] = Gst.ElementFactory.make('filesink',
                                                            'sink')
        except Gst.ElementNotFoundError:
            logging.error("Couldn't find elements", "Check if packages ",
                          "'GStreamer Good Plugins 1.0' ",
                          "'GStreamer Base Plugins 1.0' ",
                          "are installed")
            exit(-1)

        for key in self.elements:
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["sink"].set_property('location', "file.mp3")

        # Link elements
        def pad_added_callback(demux, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["sink"].get_static_pad('sink'))

        self.elements["demux"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"],
                                self.elements["demux"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
#TODO:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

########################################################################
# Schedule
class SilverSchedule():
    """
        __sched_week__      - full schedule
        __sched_day__       - daily agenda
        __event__           - currently playing

        Schedule list[weekday(0-6)]:
            0   Weekday             str
            1   IsParent            bool
            2   Time  (HH:MM-HH:MM) str
            3   Title               str
            4   URL                 str
            5   Host                [str]
            6   Icon                str
            7   start (seconds)     float
            8   end   (seconds)     float
            9   Icon URL            str
    """
    def __init__(self):
        self.__sched_week__ = [ [] for x in range(7) ]
        self.__sched_day__ = deque()
        self.__event__ = {}

    # Get current event values
    def get_event_title(self): return self.__event__["title"]
    def get_event_url(self): return self.__event__["url"]
    def get_event_end(self): return self.__event__["end"]
    def get_event_position(self): return self.__event__["position"]
    def get_event_icon(self):
        """ Return pixbuf """
        # Download icon if it doesn't exist
        if not os.path.exists(self.__event__["icon"]):
            urllib.request.urlretrieve(self.__event__["icon_url"], self.__event__["icon"])
        return GdkPixbuf.Pixbuf.new_from_file(self.__event__["icon"])

    def update_current_event(self):
        """ Update current event """
        newday = False
        if not len(self.__sched_day__):
            # It's a new day.
            # It's so mundane. What exciting things will happen today?
            print("NEW DAY")
            self._sched_gen_daily_agenda()
            newday = True
        self.__event__ = self.__sched_day__.popleft()
        return newday

    def update_schedule(self, force_refresh=False):
        """ Retrieve schedule """
        if not force_refresh and os.path.exists(SCHED_FILE):
            # Read from file
            self._sched_get_from_file()
        else:
            # Backup
            sched_week_bak = self.__sched_week__
            sched_day_bak = self.__sched_day__
            # Clear
            self.__sched_week__ = [ [] for x in range(7) ]
            self.__sched_day__ = deque()
            # Load from website
            if not self._sched_get_from_html():
                logging.error("Couldn't update")
                self.__sched_week__ = sched_week_bak
                self.__sched_day__ = sched_day_bak
                return False
        # Generate schedule for today
        self._sched_gen_daily_agenda()
        # Update current event
        self.update_current_event()
        return True

    def fill_tree_strore(self, store):
        """ Fill TreeStore object """
        it = None

        for x in range(7):
            bg_dark = False
            ch_dark = bg_dark

            for item in self.__sched_week__[x]:
                host = '\n'.join(item["host"])
                font = SCHED_FONT
                # Download icon if it doesn't exist
                if not os.path.exists(item["icon"]):
                    urllib.request.urlretrieve(item["icon_url"], item["icon"])
                if item["is_main"]:
                    # Main event
                    bg_color = SCHED_BG_COLORS[bg_dark]
                    fg_color = SCHED_FG_COLORS[bg_dark]
                    # Get pixbuf
                    icon = GdkPixbuf.Pixbuf.new_from_file(item["icon"])
                    # Insert item
                    it = store.append(None, [item["weekday"], item["is_main"],
                                             item["time"], item["title"],
                                             item["url"], host, icon,
                                             bg_color, fg_color, font])
                    # Alternate row color
                    ch_dark = bg_dark
                    bg_dark = not bg_dark
                else:
                    # Child event
                    bg_color = SCHED_CHILD_BG_COLORS[ch_dark]
                    fg_color = SCHED_CHILD_FG_COLORS[ch_dark]
                    # Get pixbuf
                    icon = GdkPixbuf.Pixbuf.new_from_file_at_scale(
                                                            item["icon"],
                                                            60, 60, True)
                    # Insert item
                    store.append(it, [item["weekday"], item["is_main"],
                                 item["time"], item["title"], item["url"],
                                 host, icon, bg_color, fg_color, font])
                    # Alternate row color
                    ch_dark = not ch_dark

    def _sched_gen_daily_agenda(self):
        """ Create a list of main events for today """
        today = datetime.now()
        now = timedelta(hours=today.hour, minutes=today.minute,
                        seconds=today.second).total_seconds()
        position = 0
        for item in self.__sched_week__[today.weekday()]:
            if not item["is_main"]:
                continue
            else:
                item["position"] = position
                position = position + 1
            if item["end"] < now:
                # Child or already ended. Skip
                continue
            self.__sched_day__.append(item)

    def _sched_get_from_file(self):
        """ Load schedule from file """
        f = open(SCHED_FILE, "r")
        self.__sched_week__ = json.load(f)
        f.close()

    def _sched_write_to_file(self):
        """ Save schedule on disk """
        f = open(SCHED_FILE, 'w')
        json.dump(self.__sched_week__, f)
        f.close()

    def _sched_get_from_html(self):
        """ Load schedule from site """
        # Create session with fake user-agent
        session = requests.Session()
        session.headers['User-Agent'] = \
                'Mozilla/5.0 (X11; Linux x86_64) ' + \
                'AppleWebKit/537.36 (KHTML, like Gecko) ' + \
                'Chrome/41.0.2227.0 Safari/537.36'
        # Default event icon
        music_icon_src = ''
        # Weekdays parser
        wd_name_list = {'Вс' : [6], 'Пн' : [0], 'Вт' : [1], 'Ср' : [2],
                        'Чт' : [3], 'Пт' : [4], 'Сб' : [5],
                        'По будням' : list(range(0,5)),
                        'По выходным' : [5, 6]}
        # Download sched
        resp = session.get(SCHED_URL)
#TODO:  handle connection error
#           return False
        # Follow redirects
        resp = session.get(resp.url)
        xhtml = resp.text
#TODO:  come up with something better
        xhtml = re.sub(
                r'^.*<div\ class="program-list">.*?(<tbody>.*?<\/tbody>).*$',
                r'\1', xhtml)
        # Handle unclosed img tags /* xhtml style */
        xhtml = re.sub(r'(<img.*?"\s*)>', r'\1/>', xhtml)
        # Parse xhtml text
        root = etree.fromstring(xhtml)
        for obj in root:
            # If time not presented
            if not len(obj[3]):
                # Event happens randomly or never
                continue
            # Get icon
            if obj[0][0][0].attrib['src'][0] == '/':
                icon_src = SILVER_URL + \
                           obj[0][0][0].attrib['src'].split("?")[0]
            else:
                icon_src = "http://" + \
                                 obj[0][0][0].attrib['src'].split("?")[0]
            icon_name = icon_src.split("/")[-1]
            # Get title
            title = obj[1][0][0].text
            # Don't parse music. Just save icon location
            if title == "Музыка":
                music_icon_src = icon_src
                continue
            # Get program url
            url = SILVER_URL + obj[1][0][0].attrib['href']
            # Get hosts
            host = []
            if len(obj[2]):
                # If hosts presented
                for it in obj[2][0]:
                    host.append(it[0][0].text)
            # Get schedule
            sched = []
            for it in obj[3][0]:
                # Expecting "WD, WD, WD : HH:MM" format
                weekday, time = it.text.split(' : ')
                wd_list = weekday.split(', ')
                start, end = time.split('-')
                for wd in wd_list:
                    #  Weekday number,
                    #  HH:MM,
                    #  start in seconds,
                    #  end in seconds
                    sched.append([wd_name_list[wd], time,
                                  parse_time(start),
                                  parse_time(end)])
            # Event type
            is_main = False
            if sched[0][3] - sched[0][2] >= 3600:
                # At least 1 hour
                is_main = True
            # Insert
            for it in sched:
                for weekday in it[0]:
                    program = {}
                    program["weekday"] = WEEKDAY_LIST[weekday]
                    program["is_main"] = is_main
                    program["time"] = it[1]
                    program["title"] = title
                    program["url"] = url
                    program["host"] = host
                    program["icon"] = IMG_DIR + icon_name
                    program["start"] = it[2]
                    program["end"] = it[3]
                    program["icon_url"] = icon_src
                    self.__sched_week__[weekday].append(program)

        for wd in range(7):
            time = 0.0
            pos = 0
            last = []
            # Sort schedule by start/parent
            self.__sched_week__[wd].sort(key = lambda x : \
                                         (x["start"], -x["is_main"]))
            # Fill spaces with music
            for item in self.__sched_week__[wd]:
                if not item["is_main"]:
                    continue
                if item["start"] > time:
                    # If doesn't start right after the last one
                    program = {}
                    program["is_main"] = True
                    program["title"] = "Музыка"
                    program["url"] = "http://silver.ru/programms/muzyka/"
                    program["host"] = []
                    program["icon"] = IMG_DIR + music_icon_src.split("/")[-1]
                    program["icon_url"] = music_icon_src
                    program["weekday"] = WEEKDAY_LIST[wd]
                    program["time"] = str_time(time, item["start"])
                    program["start"] = time
                    program["end"] = item["start"]
                    self.__sched_week__[wd].insert(pos, program)
                    pos = pos + 1
                time = item["end"]
                pos = pos + 1
                last = item
            # Check if last event doesn't go till 24:00
            if last["end"] < 86400.0:
                program = {}
                program["is_main"] = True
                program["title"] = "Музыка"
                program["url"] = "http://silver.ru/programms/muzyka/"
                program["host"] = []
                program["icon"] = IMG_DIR + music_icon_src.split("/")[-1]
                program["icon_url"] = music_icon_src
                program["weekday"] = WEEKDAY_LIST[wd]
                program["time"] = str_time(last["end"], 86400.0)
                program["start"] = last["end"]
                program["end"] = 86400.0
                self.__sched_week__[wd].insert(pos, program)
            # Sort again
            self.__sched_week__[wd].sort(key = lambda x : \
                                         (x["start"], -x["is_main"]))
        # Save sched to file
        self._sched_write_to_file()
        return True

########################################################################
# GUI
class SilverGUI(Gtk.Window):
    """ GUI """
    def __init__(self, player, recorder, sched):
        ## GStreamer
        # Player
        self._player = player
        self.__playing__ = False
        self.__volume__ = 100
        self.__muted__ = 0
        # Recorder
        self._recorder = recorder
        self.__recording__ = False
        ## Schedule
        self._schedule = sched
        self.__SCHEDULE_ERROR__ = False
        ## Timers
        # On event timer
        self._t_event = threading.Timer(0, None)
        ## Interface
        # Main window
        self.__main_window__ = True
        # Notifications
        self.notification = Notify.Notification.new("Header", "Body", "image")
        # TreeView
        self.__weekday_filter__ = date.today().strftime("%A")
        self.__cell_bg_old__ = ''
        self.__cell_fg_old__ = ''
        # Create main window
        self.main_window_create()
        # Create status icon
        self.status_icon_create()
        # Create treeview
        self.schedule_update()

### Cleanup
    def clean(self):
        self.timers_clean()

### Main Window
    def main_window_create(self):
        """ Init parent window """
        Gtk.Window.__init__(self, title="Silver Rain")
        self.set_border_width(0)
        self.set_default_size(650, 450)
        self.connect("delete-event", self.main_window_on_delete_event)
        # Container
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        ## Menubar
        menubar = self.menubar_create()
        vbox.pack_start(menubar, False, False, 0)
        sep = Gtk.Separator()
        vbox.pack_start(sep, False, False, 0)
        ## Scrolled window
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window.set_policy(Gtk.PolicyType.NEVER,
                                   Gtk.PolicyType.AUTOMATIC)
        self.scrolled_window.set_min_content_height(100)
        vbox.pack_start(self.scrolled_window, True, True, 0)
        ## Selection
        selection = self.selection_create()
        vbox.pack_start(selection, False, False, 0)
        # Controls
        control_panel = self.control_panel_create()
        vbox.pack_end(control_panel, False, False, 0)
        self.add(vbox)
        self.show_all()

    def main_window_on_delete_event(self, window, event):
        """ Hide parent window instead of destroying it """
        self.__main_window__ = False
        window.hide()
        return True

### Menubar
    def menubar_create(self):
        """ Menu bar """
        agr = Gtk.AccelGroup()
        self.add_accel_group(agr)
        menubar = Gtk.MenuBar()
        # Music
        music_menu = Gtk.Menu()
        music = Gtk.MenuItem("Music")
        music.set_submenu(music_menu)
        ## Play
        self.menubar_play = self.create_menuitem("Play",
                                          "media-playback-start")
        self.menubar_play.set_size_request(90, -1)
        self.menubar_play.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F6")
        self.menubar_play.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop
        self.menubar_stop = self.create_menuitem("Stop", "media-playback-stop")
        self.menubar_stop.set_sensitive(False)
        self.menubar_stop.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F7")
        self.menubar_stop.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Record
        self.menubar_record = self.create_menuitem("Record", "media-record")
        self.menubar_record.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F8")
        self.menubar_record.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop recording
        self.menubar_stop_recording = self.create_menuitem("Stop recording",
                                          "media-playback-stop")
        self.menubar_stop_recording.set_sensitive(False)
        self.menubar_stop_recording.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F9")
        self.menubar_stop_recording.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Mute
        self.menubar_mute = Gtk.CheckMenuItem("Mute")
        self.menubar_mute.connect("toggled", self.mute_toggle)
        key, mod = Gtk.accelerator_parse("<Control>M")
        self.menubar_mute.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Refresh
        refresh = self.create_menuitem("Update shcedule", "gtk-refresh")
        refresh.connect("activate", self.schedule_refresh)
        key, mod = Gtk.accelerator_parse("F5")
        refresh.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Preferences
        prefs = self.create_menuitem("Preferences", "gtk-preferences")
        prefs.connect("activate", self.prefs_window_create)
        key, mod = Gtk.accelerator_parse("<Control>P")
        prefs.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        key, mod = Gtk.accelerator_parse("<Control>Q")
        quit.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Separator
        sep = []
        for i in range(4):
            sep.append(Gtk.SeparatorMenuItem())
        ## Pack
        for item in [ self.menubar_play,
                      self.menubar_stop,
                      self.menubar_record,
                      self.menubar_stop_recording,
                      sep[0],
                      self.menubar_mute,
                      sep[1],
                      refresh,
                      sep[2],
                      prefs,
                      sep[3],
                      quit ]:
            music_menu.append(item)
        # Help
        help_menu = Gtk.Menu()
        help = Gtk.MenuItem("Help")
        help.set_submenu(help_menu)
        ## About
        about = self.create_menuitem("About", "gtk-about")
        about.set_size_request(90, -1)
        about.connect("activate", self.about_window_create)
        key, mod = Gtk.accelerator_parse("F1")
        about.add_accelerator("activate", agr, key,
                              mod, Gtk.AccelFlags.VISIBLE)
        help_menu.append(about)

        menubar.append(music)
        menubar.append(help)
        return menubar

    def menubar_mute_toggle(self):
        """ Set mute button active flag """
        if self.__muted__:
            self.menubar_mute.set_active(False)
        else:
            self.menubar_mute.set_active(True)

### Selection
    def selection_create(self):
        """ Create selection buttons """
        self.selection_buttons = []
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        for day in WEEKDAY_LIST:
            button = Gtk.Button(day)
            button.set_focus_on_click(True)
            button.set_size_request(80, 0)
            button.connect("clicked", self.selection_on_clicked)
            hbox.pack_start(button, True, True, 0)
            self.selection_buttons.append(button)
        return hbox

    def selection_on_clicked(self, button):
        """ Refilter treeview by selected weekday """
        self.__weekday_filter__ = button.get_label()
        self.sched_tree_model.refilter()

### Control panel
    def control_panel_create(self):
        """ Playback control panel """
        toolbar = Gtk.Toolbar()
        toolbar.set_orientation(Gtk.Orientation.HORIZONTAL)
        toolbar.set_style(Gtk.ToolbarStyle.ICONS)

        control_panel = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        control_panel.set_spacing(6)
        control_panel.set_border_width(6)
        ## Playback Button
        icon = self.get_playback_label()[1]
        self.playback_button = self.create_toolbutton(icon)
        self.playback_button.connect("clicked", self.playback_toggle)
        self.playback_button.set_tooltip_text("Play")
        ## Record Button
        icon = self.get_record_label()[1]
        self.record_button = self.create_toolbutton(icon)
        self.record_button.connect("clicked", self.record_toggle)
        self.record_button.set_tooltip_text("Record")
        ## Separator
        sep = Gtk.SeparatorToolItem()
        ## Update schedule Button
        self.sched_refresh_button = self.create_toolbutton("gtk-refresh")
        self.sched_refresh_button.connect("clicked", self.schedule_refresh)
        self.sched_refresh_button.set_tooltip_text("Update schedule")
        ## Spinner
        self.spinner = Gtk.Spinner()
        ## Label
        self.status = Gtk.Label()
        self.status.set_selectable(True)
        self.status.set_yalign(0.45)
        ## Mute Button
        icon = self.get_volume_icon()
        self.mute_button = self.create_toolbutton(icon)
        self.mute_button.connect("clicked", self.cp_on_mute)
        ## Volume scale
        ad = Gtk.Adjustment(value=self.__volume__, lower=0,
                            upper=100, step_increment=5,
                            page_increment=10, page_size=0)
        self.volume = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL,
                                adjustment=ad)
        self.volume.set_property('draw-value', False)
        self.volume.connect("value-changed", self.cp_on_volume_changed)
        self.volume.set_size_request(80, 0)
        # Pack toolbar
        for x, el in enumerate ([ self.playback_button,
                                  self.record_button,
                                  sep,
                                  self.sched_refresh_button ]):
            toolbar.insert(el, x)
        # Pack panel
        control_panel.pack_start(toolbar, False, False, 0)
        control_panel.pack_start(self.spinner, False, False, 0)
        control_panel.pack_start(self.status, True, False, 0)
        control_panel.pack_end(self.volume, False, False, 0)
        control_panel.pack_end(self.mute_button, False, False, 0)
        return control_panel

    def cp_on_volume_changed(self, scale):
        self.__volume__ = scale.get_value()
        if not self.__muted__ and self.__volume__ == 0:
            self.menubar_mute_toggle()
        elif self.__muted__ and self.__volume__ > 0:
            self.__muted__ = self.__volume__
            self.menubar_mute_toggle()
        self._player.volume_set(self.__volume__)

    def cp_on_mute(self, arg):
        self.menubar_mute_toggle()

### Status Icon
    def status_icon_create(self):
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_from_icon_name("media-tape")
        self.status_icon.connect("activate", self.status_icon_on_activate)
        self.status_icon.connect("popup-menu", self.status_icon_popup)
        self.status_icon.connect("scroll-event", self.status_icon_on_scroll)
        self.status_icon.set_tooltip_text("Silver Rain")

    def status_icon_on_activate(self, icon):
        """ Show/hide main window on left click """
        self.__main_window__ = not self.__main_window__
        if self.__main_window__:
            self.show()
        else:
            self.hide()

    def status_icon_on_scroll(self, icon, data):
        """ Change volume by scrolling on status icon """
        direction = data.direction
        if direction == Gdk.ScrollDirection.UP:
            self.__volume__ = self._player.volume_step(True)
            if self.__muted__:
                self.menubar_mute_toggle()
        elif direction == Gdk.ScrollDirection.DOWN:
            self.__volume__ = self._player.volume_step(False)
            if self.__volume__ == 0:
                self.menubar_mute_toggle()
        self.volume.set_value(self.__volume__)

    def status_icon_popup(self, icon, button, time):
        """ Show menu on right click """
        self.popup_menu = Gtk.Menu()
        # Playback
        text, icon = self.get_playback_label()
        play = self.create_menuitem(text, icon)
        play.connect("activate", self.playback_toggle)
        play.set_size_request(100, -1)
        # Record
        text, icon = self.get_record_label()
        record = self.create_menuitem(text, icon)
        record.connect("activate", self.record_toggle)
        # Mute
        mute = Gtk.CheckMenuItem("Mute")
        if self.__muted__:
            mute.set_active(True)
        mute.connect("toggled", self.popup_on_mute)
        # Preferences
        preferences = self.create_menuitem("Preferences", "gtk-preferences")
        preferences.connect("activate", self.prefs_window_create)
        # Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        # Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [play, record, sep[0], mute,
                     sep[1], preferences, sep[2], quit]:
            self.popup_menu.append(item)
        self.popup_menu.show_all()

        def pos_func(menu, x, y, icon):
            return (Gtk.StatusIcon.position_menu(menu, x, y, icon))
        self.popup_menu.popup(None, None, pos_func,
                              self.status_icon, button, time)

    def popup_on_mute(self, arg):
        self.menubar_mute_toggle()

### TreeView
    def sched_tree_model_create(self):
        """ Create schedule tree """
        store = Gtk.TreeStore(str,              # Weekday
                              bool,             # IsParent
                              str,              # Time
                              str,              # Title
                              str,              # URL
                              str,              # Host
                              GdkPixbuf.Pixbuf, # Icon
                              str,              # BackgroundColor
                              str,              # FontColor
                              str)              # Font
        self.sched_tree_model = store.filter_new()
        self.sched_tree_model.set_visible_func(self.sched_tree_model_func)
        self._schedule.fill_tree_strore(store)
        self.__cell_bg_old__ = ''
        self.__cell_fg_old__ = ''

    def sched_tree_model_func(self, model, iter, data):
        """ Filter by weekday """
        return model[iter][0] == self.__weekday_filter__

    def sched_tree_create(self):
        """ Create schedule tree """
        self.sched_tree_model_create()

        self.sched_tree = Gtk.TreeView.new_with_model(self.sched_tree_model)
        self.sched_tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)
        self.sched_tree.connect('button-release-event',
                           self.sched_tree_on_button_release_event)
        # Icon
        renderer = Gtk.CellRendererPixbuf()
        column = Gtk.TreeViewColumn(" ", renderer, pixbuf=6)
        renderer.set_alignment(1, 0.5)
        self.sched_tree.append_column(column)

        renderer = Gtk.CellRendererText()
        renderer.set_padding(10, 0)
        renderer.set_alignment(0.5, 0.5)
        # Time
        column = Gtk.TreeViewColumn("Time", renderer,
                                    text=2, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(10)
        self.sched_tree.append_column(column)
        # Title
        renderer.set_alignment(0, 0.5)
        column = Gtk.TreeViewColumn("Title", renderer,
                                    text=3, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        self.sched_tree.append_column(column)
        # Host
        column = Gtk.TreeViewColumn("Host", renderer,
                                    text=5, background=7, foreground=8, font=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        self.sched_tree.append_column(column)

        self.scrolled_window.add(self.sched_tree)
        self.scrolled_window.show_all()

    def sched_tree_on_button_release_event(self, widget, event):
        if not event.button == 3:
            return
        selection = self.sched_tree.get_selection()
        model, iter = selection.get_selected()
        # Create popup menu
        self.sched_popup = Gtk.Menu()
        # Program url
        url = self.create_menuitem("Program page", "web-browser")
        url.set_size_request(100, -1)
        event_url = model.get_value(iter, 4)
        url.connect("activate", self.url_open, event_url)
        self.sched_popup.append(url)
        # Record program
        icon = self.get_record_label()[1]
        rec = self.create_menuitem("Set recording", icon)
        event_time = model.get_value(iter, 2)
        rec.connect("activate", self.sched_record, event_time)
        self.sched_popup.append(rec)
        self.sched_popup.show_all()
        self.sched_popup.popup(None, None,
                               None, None,
                               event.button, event.time)

    def url_open(self, button, url):
        subprocess.Popen(['xdg-open', url], stdout=subprocess.PIPE)

    def sched_record(self, button, time):
        print(time)
        pass

### Timers
    def timers_clean(self):
        """ Cancel timer """
        self._t_event.cancel()

    def timers_reset(self):
        """ Reset timer """
        self.timers_clean()
        self.timers_init_event_timer()

    def timers_init_event_timer(self):
        """ Raise handler when event ends """
        today = datetime.now()
        now = timedelta(hours=today.hour,
                minutes=today.minute, seconds=today.second).total_seconds()
        timeout = int(self._schedule.get_event_end() - now)
        print("NEW TIMER WITH TIMEOUT:", timeout)
        self._t_event = threading.Timer(timeout, self.timers_callback_event)
        self._t_event.start()

    def timers_callback_event(self):
        """ Update schedule """
        print("TIMER CALLBACK")
        self.update_now_playing()
        # Init new timer
        self.timers_init_event_timer()

### Updater
    def schedule_refresh(self, button): self.schedule_update(refresh=True)

    def schedule_update(self, refresh=False):
        """ Initialize schedule, create treeview and start timers
            This might take a while, so run in thread """
        def init_sched():
            # Initialize schedule
            ret = self._schedule.update_schedule(refresh)
            if not ret:
                self.__SCHEDULE_ERROR__ = True
                if refresh:
                    self.timers_clean()
                GObject.idle_add(error)
            if not refresh:
                # Initialization
                # Create treeview
                self.sched_tree_create()
                # Initialize timers
                self.timers_init_event_timer()
            else:
                # Refresh treeview
                self.sched_tree_model_create()
                self.sched_tree.set_model(self.sched_tree_model)
                self.timers_reset()
            GObject.idle_add(cleanup)

        def cleanup():
            t.join()
            # Show playing status
            self.status_set_playing()
            # Update selection
            self.selection_update()
            # Mark current row
            self.sched_tree_mark_current()

        def error():
            t.join()
            # Show error status
            self.status_set_error()

        # Show updating status
        self.status_set_schedule_updating()
        # Reset error flag
        self.__SCHEDULE_ERROR__ = False
        # Show updating message
        t = threading.Thread(target=init_sched)
        t.start()

    def selection_update(self):
        """ Update selection """
        today = date.today().weekday()
        self.selection_buttons[today].clicked()
        Gtk.Widget.grab_focus(self.selection_buttons[today])

    def status_set_schedule_updating(self):
        """ Show spinner and "Updating" message """
        self.sched_refresh_button.hide()
        self.spinner.show()
        self.spinner.start()
        self.status.set_text("<span size='12000'><b>" +
                             "Updating schedule..." + "</b></span>")
        self.status.set_use_markup(True)

    def status_set_playing(self):
        """ Hide spinner and show currently playing """
        self.spinner.stop()
        self.spinner.hide()
        self.sched_refresh_button.show()
        self.status_update()

    def status_set_error(self):
        """ Hide spinner and show error """
        self.spinner.stop()
        self.spinner.hide()
        self.sched_refresh_button.show()
        self.status.set_text("<span size='12000'><b>" +
                             "Couldn't update schedule" + "</b></span>")
        self.status.set_use_markup(True)

    def status_update(self):
        """ Show program name in status """
        if not self.__SCHEDULE_ERROR__:
            self.status.set_text("<span size='12000'><b>" +
                                 self._schedule.get_event_title() +
                                 "</b></span>")
            self.status.set_use_markup(True)

    def sched_tree_mark_current(self):
        """ Set current event colors """
        if self.__SCHEDULE_ERROR__:
            return
        # Get current position
        pos = self._schedule.get_event_position()
        if self.__cell_bg_old__:
            # Reset previous row
            print("RESET PREV ITER COLORS")
            self.sched_tree_model[self.__iter_old__][7] = self.__cell_bg_old__
            self.sched_tree_model[self.__iter_old__][8] = self.__cell_fg_old__
            self.sched_tree_model[self.__iter_old__][9] = SCHED_FONT
            self.cell_bg_old = ''
            self.cell_fg_old = ''
        # Set current row color
        path = Gtk.TreePath(pos)
        iter = self.sched_tree_model.get_iter(path)
        self.__cell_bg_old__ = self.sched_tree_model[iter][7]
        self.__cell_fg_old__ = self.sched_tree_model[iter][8]
        self.__iter_old__ = iter
        self.sched_tree_model[iter][7] = SCHED_CURRENT_BG_COLOR
        self.sched_tree_model[iter][8] = SCHED_CURRENT_FG_COLOR
        self.sched_tree_model[iter][9] = SCHED_CURRENT_FONT
        # Scroll to current cell
        path = Gtk.TreePath(pos)
        self.sched_tree.scroll_to_cell(path, use_align=True, row_align=0.5)

    def update_now_playing(self):
        """ Update label, bg of current event, show notifications """
        if self._schedule.update_current_event():
            # Update selection
            GObject.idle_add(self.selection_update)

        self.sched_tree_mark_current()
        self.status_update()
        self.show_notification_on_event()

### Preferences window
    def prefs_window_create(self, something):
        pass

### About window
    def about_window_create(self, icon):
        def uri_open(uri):
            Popen(['xdg-open', uri], stdout=PIPE)
        about = Gtk.AboutDialog()
        about.set_name("Silver Rain")
        about.set_version("0.1")
        about.set_copyright('Copyright \xa9 2015 Petr Skovoroda')
        about.set_comments('Silver Rain radio player')
        about.set_website('http://silver.ru')
        about.run()
        about.destroy()

### Common
    def create_menuitem(self, text, icon):
        """ Create Menu item with icon """
        icontheme = Gtk.IconTheme.get_default()
        icon = icontheme.load_icon(icon, 16, 0)
        img = Gtk.Image()
        img.set_from_pixbuf(icon)

        # Depricated, but Gtk.Box looks like shit
        menuitem = Gtk.ImageMenuItem()
        menuitem.set_image(img)
        menuitem.set_label(text)
        return menuitem

    def create_toolbutton(self, icon):
        """ Toolbar button """
        button = Gtk.ToolButton()
        button.set_icon_name(icon)
        return button

    def playback_toggle(self, button):
        self.__playing__ = not self.__playing__
        self.playback_button.set_icon_name(self.get_playback_label()[1])

        if self.__playing__:
            self.menubar_play.set_sensitive(False)
            self.menubar_stop.set_sensitive(True)
            self.playback_button.set_tooltip_text("Stop")
        else:
            self.menubar_play.set_sensitive(True)
            self.menubar_stop.set_sensitive(False)
            self.playback_button.set_tooltip_text("Play")

        self._player.playback_toggle()
        self.show_notification_on_playback()

    def record_toggle(self, button):
        self.__recording__ = not self.__recording__
        self.record_button.set_icon_name(self.get_record_label()[1])
        if self.__recording__:
            self.menubar_record.set_sensitive(False)
            self.menubar_stop_recording.set_sensitive(True)
            self.record_button.set_tooltip_text("Stop recording")
        else:
            self.menubar_record.set_sensitive(True)
            self.menubar_stop_recording.set_sensitive(False)
            self.record_button.set_tooltip_text("Record")

        if not __SCHEDULE_ERROR__:
            name = self._schedule.get_event_title()
        else:
            name = "SilverRain"
        self._recorder.record_toggle(name)

    def mute_toggle(self, button, val=0):
        if self.__muted__:
            self.__volume__ = self.__muted__
            self.__muted__ = 0
        else:
            self.__muted__ = self.__volume__ or 5
            self.__volume__ = 0

        self._player.volume_set(self.__volume__)
        self.mute_button.set_icon_name(self.get_volume_icon())
        self.volume.set_value(self.__volume__)

    def get_playback_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__playing__:
            label = "Play"
            icon = "media-playback-start"
        else:
            label = "Stop"
            icon = "media-playback-stop"
        return label, icon

    def get_record_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__recording__:
            label = "Record"
            icon = "media-record"
        else:
            label = "Stop recording"
            icon = "media-playback-stop"
        return label, icon

    def get_volume_icon(self):
        """ Return label and icon for Playback menu/button """
        if self.__muted__:
            icon = "audio-volume-muted"
        else:
            icon = "audio-volume-high"
        return icon

    def show_notification_on_event(self):
        """ Show currently playing """
        text = "Silver Rain"
        if not self.__SCHEDULE_ERROR__:
            body = self._schedule.get_event_title()
            self.notification.set_icon_from_pixbuf(
                    self._schedule.get_event_icon())
            self.notification.update(text, body)
        else:
            body = "Playing"
            img = "notification-audio-stop"
            self.notification.update(text, body, img)
        self.notification.show()

    def show_notification_on_playback(self):
        if self.__playing__:
            self.show_notification_on_event()
        else:
            text = "Silver Rain"
            body = "Stopped"
            img = "notification-audio-stop"
            self.notification.update(text, body, img)
            self.notification.show()

# Common
def str_time(start, end):
    """ Return time in HH:MM-HH:MM """
    s_h, s_m = divmod(int(start), 3600)
    e_h, e_m = divmod(int(end), 3600)
    return "{0:0=2d}:{1:0=2d}-{2:0=2d}:{3:0=2d}".format(s_h, s_m, e_h, e_m)

def parse_time(str):
    """ Return time in seconds """
    try:
        x = datetime.strptime(str, "%H:%M")
    except ValueError:
        # except 24:00
        # Fuck timedelta and python-floating-point-approximation shit
        # Just return the correct value
        return 86400.0
    d = timedelta(hours=x.hour, minutes=x.minute)
    return d.total_seconds()

########################################################################
# Boom, baby
GObject.threads_init()
Gst.init(None)
signal.signal(signal.SIGINT, signal.SIG_DFL)
Notify.init("Silver Rain")
# Create directories if they don't exist
for dir in [APP_DIR, IMG_DIR, RECS_DIR]:
    if not os.path.exists(dir):
        os.makedirs(dir)
# Init
silver_player = SilverPlayer()
silver_recorder = SilverRecorder()
silver_schedule = SilverSchedule()
silver_window = SilverGUI(silver_player, silver_recorder, silver_schedule)
# Run loop
Gtk.main()
# Cleanup
Notify.uninit()
silver_window.clean()
silver_player.clean()
silver_recorder.clean()
