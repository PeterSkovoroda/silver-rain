#!/usr/bin/env python3

import gi
gi.require_version("Gst", "1.0")
gi.require_version("Gtk", "3.0")
from gi.repository import Gst, Gtk, GObject, Gdk
from gi.repository.GdkPixbuf import Pixbuf
#TODO: check if exist
import notify2

import signal
import logging

stream_url_list = [
        'http://icecast.silver.cdnvideo.ru/silver',
        'http://radiosilver.corbina.net:8000/silver128.mp3',
        'http://radiosilver.corbina.net:8000/silver48.mp3'
        ]
broadcast_url = stream_url_list[0]

css_path = 'silver-rain.css'

# Own style
#style_provider = Gtk.CssProvider()
#css = open(css_path, 'rb')
#css_data = css.read()
#css.close()
#style_provider.load_from_data(css_data)
#Gtk.StyleContext.add_provider_for_screen (Gdk.Screen.get_default(), style_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

class SilverPlayer():
    """ Gstreamer container for playing network audio stream
        sophttpsrc -> decodebin -> audioconvert -> volume -> autoaudiosink"""
    def __init__(self):
        self.__playing__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.pipeline.set_state(Gst.State.NULL)

    def playback_get(self):
        """ Return playback status """
        return self.__playing__

    def playback_toggle(self):
        """ Playback trigger """
        self.__playing__ = not self.__playing__
        if self.__playing__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def volume_get(self):
        """ Return volume """
        value = int(self.pipeline.get_by_name('volume').get_property('volume') * 100.)
        return value

    def volume_set(self, value):
        """ Set player volume [0-100] """
        self.pipeline.get_by_name('volume').set_property('volume', value / 100.)

    def volume_step(self, increase):
        """ Increase/decrease volume by 5
            Returns new value """
        value = self.pipeline.get_by_name('volume').get_property('volume')
        if increase:
            if value >= 0.95:
                value = 1.
            else:
                value = value + 0.05
        else:
            if value <= 0.05:
                value = 0.
            else:
                value = value - 0.05
        self.pipeline.get_by_name('volume').set_property('volume', value)
        return int(value * 100.)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverPlayer")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc', 'source')
        self.elements["decode"] = Gst.ElementFactory.make('decodebin', 'decode')
        self.elements["convert"] = Gst.ElementFactory.make('audioconvert', 'convert')
        self.elements["volume"] = Gst.ElementFactory.make('volume', 'volume')
        self.elements["sink"] = Gst.ElementFactory.make('autoaudiosink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', broadcast_url)
        self.elements["source"].set_property('is-live', True)
        self.elements["volume"].set_property('volume', 1.)

        # Link elements
        def pad_added_callback(decode, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["convert"].get_static_pad('sink'))

        self.elements["decode"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"], self.elements["decode"]) or \
           not Gst.Element.link(self.elements["convert"], self.elements["volume"]) or \
           not Gst.Element.link(self.elements["volume"], self.elements["sink"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(), err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

class SilverRecorder():
    """ Gstreamer container for audio recording
        sophttpsrc -> icydemux -> filesink """
    def __init__(self):
        self.__recording__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.pipeline.set_state(Gst.State.NULL)

    def record_get(self):
        """ Return recorder status """
        return self.__recording__

    def record_toggle(self):
        """ Record trigger """
        self.__recording__ = not self.__recording__
        if self.__recording__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverRecorder")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc', 'source')
        self.elements["demux"] = Gst.ElementFactory.make('icydemux', 'demux')
        self.elements["sink"] = Gst.ElementFactory.make('filesink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', broadcast_url)
        self.elements["source"].set_property('is-live', True)
        self.elements["sink"].set_property('location', "file.mp3")

        # Link elements
        def pad_added_callback(demux, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["sink"].get_static_pad('sink'))

        self.elements["demux"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"], self.elements["demux"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(), err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

class SilverGUI(Gtk.Window):
    """ GUI """
    def __init__(self, player, recorder):
        self.__playing__ = False
        self.__player__ = player
        self.__recording__ = False
        self.__recorder__ = recorder
        self.__volume__ = 100
        self.__muted__ = 0

        self.__main_window__ = True
        self.__about_window__ = False
        self.__prefs_window__ = False

        self.create_main_window()
        self.create_status_icon()
#TODO   self.create_notification()
        self.notification = notify2.Notification("", "", "")

### Main Window
    def create_main_window(self):
        """ Init top window """
        Gtk.Window.__init__(self, title="Silver Rain")
        self.set_border_width(0)
        self.set_default_size(250, 50)
        self.connect("delete-event", self.mw_on_delete_event)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)

        menubar = self.create_menubar()
        vbox.pack_start(menubar, False, False, 0)

        sep = Gtk.Separator()
        vbox.pack_start(sep, False, False, 0)

        control_panel = self.create_control_panel()
        vbox.pack_start(control_panel, False, False, 0)

        self.add(vbox)
        self.show_all()

    def mw_on_delete_event(self, window, event):
        """ Hide top window instead of destroying it """
        self.__main_window__ = False
        window.hide()
        return True

### Menubar
    def create_menubar(self):
        """ Menu bar """
        agr = Gtk.AccelGroup()
        self.add_accel_group(agr)
        menubar = Gtk.MenuBar()
        # Music
        music_menu = Gtk.Menu()
        music = Gtk.MenuItem("Music")
        music.set_submenu(music_menu)
        ## Play
        self.menubar_play = self.create_menuitem("Play", "media-playback-start")
        self.menubar_play.set_size_request(90, -1)
        self.menubar_play.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F6")
        self.menubar_play.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop
        self.menubar_stop = self.create_menuitem("Stop", "media-playback-stop")
        self.menubar_stop.set_sensitive(False)
        self.menubar_stop.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F7")
        self.menubar_stop.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Record
        self.menubar_record = self.create_menuitem("Record", "media-record")
        self.menubar_record.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F8")
        self.menubar_record.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop recording
        self.menubar_stop_recording = self.create_menuitem("Stop recording", "media-playback-stop")
        self.menubar_stop_recording.set_sensitive(False)
        self.menubar_stop_recording.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F9")
        self.menubar_stop_recording.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Mute
        self.menubar_mute = Gtk.CheckMenuItem("Mute")
        self.menubar_mute.connect("toggled", self.mute_toggle)
        key, mod = Gtk.accelerator_parse("<Control>M")
        self.menubar_mute.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Preferences
        prefs = self.create_menuitem("Preferences", "gtk-preferences")
        prefs.connect("activate", self.create_prefs_window)
        key, mod = Gtk.accelerator_parse("<Control>P")
        prefs.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        ## Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        key, mod = Gtk.accelerator_parse("<Control>Q")
        quit.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)

        ## Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [self.menubar_play, self.menubar_stop,
                     self.menubar_record, self.menubar_stop_recording,
                     sep[0], self.menubar_mute, sep[1], prefs, sep[2], quit]:
            music_menu.append(item)

        # Help
        help_menu = Gtk.Menu()
        help = Gtk.MenuItem("Help")
        help.set_submenu(help_menu)
        ## About
        about = self.create_menuitem("About", "gtk-about")
        about.set_size_request(90, -1)
        about.connect("activate", self.create_about_window)
        key, mod = Gtk.accelerator_parse("F1")
        about.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        help_menu.append(about)

        menubar.append(music)
        menubar.append(help)

        return menubar

    def menubar_mute_toggle(self):
        if self.__muted__:
            self.menubar_mute.set_active(False)
        else:
            self.menubar_mute.set_active(True)

### Toolbar
    def create_control_panel(self):
        """ Playback control buttons """
        toolbar = Gtk.Toolbar()
        toolbar.set_orientation(Gtk.Orientation.HORIZONTAL)
        toolbar.set_style(Gtk.ToolbarStyle.ICONS)

        control_panel = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        ## Playback Button
        icon = self.get_playback_label()[1]
        self.playback_button = self.create_toolbutton(icon)
        self.playback_button.connect("clicked", self.playback_toggle)
        ## Record Button
        icon = self.get_record_label()[1]
        self.record_button = self.create_toolbutton(icon)
        self.record_button.connect("clicked", self.record_toggle)
        self.record_button.focus_on_click = True
        ## Mute Button
        icon = self.get_volume_icon()
        self.mute_button = self.create_toolbutton(icon)
        self.mute_button.connect("clicked", self.cp_on_mute)

        toolbar.insert(self.playback_button, 0)
        toolbar.insert(self.record_button, 1)
        toolbar.insert(self.mute_button, 2)
        ## Volume scale
        ad = Gtk.Adjustment(value=self.__volume__, lower=0, upper=100, step_increment=5, page_increment=10, page_size=0)
        self.volume = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=ad)
        self.volume.set_property('draw-value', False)
        self.volume.connect("value-changed", self.cp_on_volume_changed)
        self.volume.set_size_request(80, 0)

        control_panel.pack_start(toolbar, False, False, 0)
        control_panel.pack_start(self.volume, False, False, 0)

        return control_panel

    def cp_on_volume_changed(self, scale):
        self.__volume__ = scale.get_value()
        if not self.__muted__ and self.__volume__ == 0:
            self.menubar_mute_toggle()
        if self.__muted__ and self.__volume__ > 0:
            self.__muted__ = self.__volume__
            self.menubar_mute_toggle()
        self.__player__.volume_set(self.__volume__)

    def cp_on_mute(self, arg):
        self.menubar_mute_toggle()

    def create_toolbutton(self, icon):
        ## Playback Button
        button = Gtk.ToolButton()
        button.set_icon_name(icon)
        button.focus_on_click = False
        return button

### Popup menu
    def create_popup_menu(self, icon, button, time):
        """ Show menu on right click """
        self.popup_menu = Gtk.Menu()
        # Playback
        text, icon = self.get_playback_label()
        play = self.create_menuitem(text, icon)
        play.connect("activate", self.playback_toggle)
        play.set_size_request(100, -1)
        # Record
        text, icon = self.get_record_label()
        record = self.create_menuitem(text, icon)
        record.connect("activate", self.record_toggle)
        # Mute
        mute = Gtk.CheckMenuItem("Mute")
        if self.__muted__:
            mute.set_active(True)
        mute.connect("toggled", self.popup_mute)
        # Preferences
        preferences = self.create_menuitem("Preferences", "gtk-preferences")
        preferences.connect("activate", self.create_prefs_window)
        # Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        # Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [play, record, sep[0], mute, sep[1], preferences, sep[2], quit]:
            self.popup_menu.append(item)
        self.popup_menu.show_all()

        def pos_func(menu, x, y, icon):
            return (Gtk.StatusIcon.position_menu(menu, x, y, icon))
        self.popup_menu.popup(None, None, pos_func, self.status_icon, button, time)

    def popup_mute(self, arg):
        self.menubar_mute_toggle()

### Status Icon
    def create_status_icon(self):
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_from_icon_name("media-tape")
        self.status_icon.connect("activate", self.status_icon_on_activate)
        self.status_icon.connect("popup-menu", self.create_popup_menu)
        self.status_icon.connect("scroll-event", self.status_icon_on_scroll)

    def status_icon_on_activate(self, icon):
        """ Show/hide main window on left click """
        self.__main_window__ = not self.__main_window__
        if self.__main_window__:
            self.show()
        else:
            self.hide()

    def status_icon_on_scroll(self, icon, data):
        """ Change volume by scrolling on status icon """
        direction = data.direction
        if direction == Gdk.ScrollDirection.UP:
            self.__volume__ = self.__player__.volume_step(True)
            if self.__muted__:
                self.menubar_mute_toggle()
        elif direction == Gdk.ScrollDirection.DOWN:
            self.__volume__ = self.__player__.volume_step(False)
            if self.__volume__ == 0:
                self.menubar_mute_toggle()
        self.volume.set_value(self.__volume__)

### Preferences window
    def create_prefs_window(self, something):
        pass

### About window
    def create_about_window(self, icon):
        def uri_open(uri):
            Popen(['xdg-open', uri], stdout=PIPE)
        about = Gtk.AboutDialog()
        about.set_name("Silver Rain")
        about.set_version("0.1")
        about.set_copyright('Copyright \xa9 2015 Petr Skovoroda')
        about.set_comments('Silver Rain radio player')
        about.set_website('http://silver.ru')
        about.run()
        about.destroy()

### Common
    def create_menuitem(self, text, icon):
        """ Create Menu item with icon """
        icontheme = Gtk.IconTheme.get_default()
        icon = icontheme.load_icon(icon, 16, 0)
        img = Gtk.Image()
        img.set_from_pixbuf(icon)

        menuitem = Gtk.ImageMenuItem()
        menuitem.set_image(img)
        menuitem.set_label(text)
        return menuitem

    def playback_toggle(self, button):
        self.__playing__ = not self.__playing__
        self.playback_button.set_icon_name(self.get_playback_label()[1])

        if self.__playing__:
            self.menubar_play.set_sensitive(False)
            self.menubar_stop.set_sensitive(True)
        else:
            self.menubar_play.set_sensitive(True)
            self.menubar_stop.set_sensitive(False)

        self.__player__.playback_toggle()
        self.show_notification()

    def record_toggle(self, button):
        self.__recording__ = not self.__recording__
        self.record_button.set_icon_name(self.get_record_label()[1])
        if self.__recording__:
            self.menubar_record.set_sensitive(False)
            self.menubar_stop_recording.set_sensitive(True)
        else:
            self.menubar_record.set_sensitive(True)
            self.menubar_stop_recording.set_sensitive(False)

        self.__recorder__.record_toggle()

    def mute_toggle(self, button, val=0):
        if self.__muted__:
            self.__volume__ = self.__muted__
            self.__muted__ = 0
        else:
            self.__muted__ = self.__volume__ or 5
            self.__volume__ = 0

        self.__player__.volume_set(self.__volume__)
        self.mute_button.set_icon_name(self.get_volume_icon())
        self.volume.set_value(self.__volume__)

    def get_playback_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__playing__:
            label = "Play"
            icon = "media-playback-start"
        else:
            label = "Stop"
            icon = "media-playback-stop"
        return label, icon

    def get_record_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__recording__:
            label = "Record"
            icon = "media-record"
        else:
            label = "Stop recording"
            icon = "media-playback-stop"
        return label, icon

    def get_volume_icon(self):
        """ Return label and icon for Playback menu/button """
        if self.__muted__:
            icon = "audio-volume-muted"
        else:
            icon = "audio-volume-high"
        return icon

    def show_notification(self):
        if self.__playing__:
            text = "Playing"
            body = "Silver Rain"
            img = "notification-audio-play"
        else:
            text = "Stopped"
            body = "Silver Rain"
            img = "notification-audio-stop"
        self.notification.update(text, body, img)
        self.notification.show()

GObject.threads_init()
Gst.init(None)
signal.signal(signal.SIGINT, signal.SIG_DFL)
notify2.init('')

player = SilverPlayer()
recorder = SilverRecorder()
silver = SilverGUI(player, recorder)

Gtk.main()
player.clean()
recorder.clean()
