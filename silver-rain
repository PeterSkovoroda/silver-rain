#!/usr/bin/env python

__program__ = 'silver-rain'

import datetime
import gi
import logging
import os
import re
import signal
import threading
import urllib.request
import json

from collections import deque

gi.require_version("Gst", "1.0")
gi.require_version("Gtk", "3.0")
from gi.repository import Gst, Gtk, GObject, Gdk
from gi.repository import GdkPixbuf
from gi.repository import Notify

try:
    from lxml import etree
except ImportError as err:
    import xml.etree.ElementTree as etree

# Stream
STREAM_URL_LIST = [
        'http://icecast.silver.cdnvideo.ru/silver',
        'http://radiosilver.corbina.net:8000/silver128.mp3',
        'http://radiosilver.corbina.net:8000/silver48.mp3'
        ]
SILVER_STREAM_URL = STREAM_URL_LIST[0]

# System files
APP_DIR = ".silver/"
IMG_DIR = APP_DIR + "imgs/"
RECS_DIR = os.getenv("HOME") + "/SilverRain/"
SILVER_URL = "http://silver.ru"
SCHED_FILE = APP_DIR + "sched.xml"
SCHED_HTML = APP_DIR + "sched.html"
SCHED_JSON = APP_DIR + "sched.dump"
SCHED_URL = "http://silver.ru/programms/"

# Own style
css_path = 'silver-rain.css'
#style_provider = Gtk.CssProvider()
#css = open(css_path, 'rb')
#css_data = css.read()
#css.close()
#style_provider.load_from_data(css_data)
#Gtk.StyleContext.add_provider_for_screen (Gdk.Screen.get_default(),
#                                       style_provider,
#                                       Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)

# Colors
# * Silver red - #FF4545
# * Reddit red - #FF4C4C
# * Kinda yellow - beige
SCHEDULE_BG_COLORS      = ["white", "#FFD9D9"]
SCHEDULE_FONT_COLORS    = ["black", "black"]
CHILD_BG_COLORS         = ["#FFEBEB", "gray93"]
CHILD_FONT_COLORS       = ["black", "black"]

# If one day I'll try to translate this shit
WEEKDAY_LIST = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday', 'Sunday']

### Timers
class SilverTimer():
    def __init__(self, sched, window):
        self.__sched__ = sched
        self.__window__ = window

        self.__t_newday__ = threading.Timer(0, None)
        self.__t_main__ = threading.Timer(0, None)
        self.__t_child__ = threading.Timer(0, None)

        self.init_new_day_timer()
        self.init_main_timer()
        self.init_child_timer()

    def clean(self):
        self.__t_newday__.cancel()
        self.__t_main__.cancel()
        self.__t_child__.cancel()

    def init_main_timer(self):
        """ Event timer """
        today = datetime.datetime.now()
        now = datetime.timedelta(hours=today.hour,
                minutes=today.minute, seconds=today.second).total_seconds()
        event = self.__sched__.get_next_event()
        if event:
            time = int(event[8] - now)
            #print("-->MAIN TIMER ON EVENT:", event, "WITH TIMEOUT", time)
            self.__t_main__ = threading.Timer(time, self.t_callback_main)
            self.__t_main__.start()

    def init_child_timer(self):
        """ Children timer """
        today = datetime.datetime.now()
        now = datetime.timedelta(hours=today.hour,
                minutes=today.minute, seconds=today.second).total_seconds()
        event = self.__sched__.get_current()
        if event[1]:
            event = self.__sched__.get_next_child()
            if event:
                time = int(event[8] - now)
                #print("-->CHILD TIMER ON EVENT:", event, "WITH TIMEOUT", time)
                self.__t_child__ = threading.Timer(time,
                        self.t_callback_child)
                self.__t_child__.start()
        else:
            # Already started. Timer on end
            time = int(event[9] - now)
            #print("-->CHILD TIMER ON ENDING:", event, "WITH TIMEOUT", time)
            self.__t_child__ = threading.Timer(time,
                    self.t_callback_child)
            self.__t_child__.start()

    def init_new_day_timer(self):
        """ Updater timer """
        today = datetime.datetime.now()
        now = datetime.timedelta(hours=today.hour,
                minutes=today.minute, seconds=today.second).total_seconds()
        next = datetime.time.max
        tomorrow = datetime.timedelta(hours=next.hour,
                minutes=next.minute, seconds=next.second).total_seconds()
        time = int(tomorrow - now) + 1
        #print("-->UPDATER TIMER WITH TIMEOUT", time)
        self.__t_newday__ = threading.Timer(time, self.t_callback_newday)
        self.__t_newday__.start()

    def t_callback_newday(self):
        """ Update agenda at 00:00 """
        #print("Newday callback")
        self.__sched__.sched_update_current()
        self.__window__.update_status()
        self.init_main_timer()
        self.init_child_timer()
        self.init_new_day_timer()

    def t_callback_main(self):
        self.__sched__.sched_update_current()
        self.__window__.update_status()
        self.init_main_timer()

    def t_callback_child(self):
        self.__sched__.sched_update_current()
        self.__window__.update_status()
        self.init_child_timer()

### Schedule
class SilverSchedule():
    """
        __sched_week__      - full schedule
        __sched_day__       - daily agenda
        __event__           - currently playing
        __main_event__      - current event

        Schedule list[weekday(0-6)]:
            0   Weekday             str
            1   IsParent            bool
            2   Time  (HH:MM-HH:MM) str
            3   Title               str
            4   URL                 str
            5   Host                [str]
            6   Host URL            [str]
            7   Icon                pixbuf
            8   start (seconds)     float
            9   end   (seconds)     float
    """
    def __init__(self):
        self.__sched_week__ = [ [] for x in range(7) ]
        self.__sched_day__ = deque()
        # Get schedule from file
        if not os.path.exists(SCHED_JSON):
            self.sched_get_from_html()
        else:
            f = open(SCHED_JSON, "r")
            self.__sched_week__ = json.load(f)
            f.close()
        self.sched_gen_daily_agenda()
        # Update current events
        self.sched_update_current()

    def sched_gen_daily_agenda(self):
        today = datetime.datetime.now()
        now = datetime.timedelta(hours=today.hour,
                minutes=today.minute).total_seconds()
        for item in self.__sched_week__[today.weekday()]:
            if item[9] < now:
                # Already happened
                continue
            self.__sched_day__.append(item)

    def sched_update_current(self):
        if not self.__sched_day__:
            # It's a new day..
            # It's so mundane. What exciting things will happen today?..
            self.sched_gen_daily_agenda()

        today = datetime.datetime.now()
        now = datetime.timedelta(hours=today.hour,
                                 minutes=today.minute,
                                 seconds=today.second).total_seconds()

        if self.__sched_day__[0][8] > now:
            # Last child ended,
            # Event not happened yet
            self.__event__ = self.__main_event__
        else:
            item = self.__sched_day__.popleft()
            if item[1]:
                self.__main_event__ = item
            self.__event__ = item
        # Check, if next is child and started already
        if len(self.__sched_day__) and \
                not self.__sched_day__[0][1] and \
                self.__sched_day__[0][8] <= now:
            item = self.__sched_day__.popleft()
            self.__event__ = item
        print(self.__event__)

    def sched_get_from_html(self):
        # Download sched
        #TODO: come up with something better
        text = urllib.request.urlopen(SCHED_URL).read().decode("utf-8")
        text = re.sub(r'^.*<div\ class="program-list">.*?(<tbody>.*?<\/tbody>).*$', r'\1', text)
        text = re.sub(r'(<img.*?"\s*)>', r'\1/>', text)

        root = etree.fromstring(text)
        wd_name_list = {'Вс' : [6], 'Пн' : [0], 'Вт' : [1], 'Ср' : [2],
                        'Чт' : [3], 'Пт' : [4], 'Сб' : [5],
                        'По будням' : list(range(0,5)),
                        'По выходным' : [5, 6]}
        default_icon_src = ''
        # Parse HTML
        for obj in root:
            #
            if not len(obj[3]):
                continue
            # Don't parse music. Just fill spaces with it
            if obj[1][0][0].text == "Музыка":
                default_icon_src = "http:" + obj[0][0][0].attrib['src'].split("?")[0]
                continue
            # Get icon
            icon_src = "http:" + obj[0][0][0].attrib['src'].split("?")[0]
            icon_name = icon_src.split("/")[-1]
            if not os.path.exists(IMG_DIR + icon_name):
                urllib.request.urlretrieve(icon_src, IMG_DIR + icon_name)
            # Get title
            title = obj[1][0][0].text
            # Get program url
            url = SILVER_URL + obj[1][0][0].attrib['href']
            # Get host
            host = []
            host_url = []
            if len(obj[2]):
                for it in obj[2][0]:
                    host.append(it[0][0].text)
                    host_url.append(SILVER_URL + it[0][0].attrib['href'])
            # Get schedule
            sched = []
            for t in obj[3][0]:
                weekday, time = t.text.split(' : ')
                wd_list = weekday.split(', ')
                start, end = time.split('-')
                for wd in wd_list:
                    sched.append([wd_name_list[wd], time,
                                  self.sched_parse_time(start),
                                  self.sched_parse_time(end)])
            # Event type
            is_main = False
            if sched[0][3] - sched[0][2] >= 3600:
                is_main = True

            # Insert
            for it in sched:
                for weekday in it[0]:
                    self.__sched_week__[weekday].append([WEEKDAY_LIST[weekday],
                        is_main, it[1], title, url, host, host_url, IMG_DIR + icon_name,
                        it[2], it[3]])


        # Default icon
        icon_name = default_icon_src.split("/")[-1]
        if not os.path.exists(IMG_DIR + icon_name):
            urllib.request.urlretrieve(default_icon_src, IMG_DIR + icon_name)
        icon = IMG_DIR + icon_name

        for x in range(7):
            # Sort
            self.__sched_week__[x].sort(key = lambda x : (x[8], -x[1]))
            # Fill spaces with music
            time = 0.0
            pos = 0
            last = []

            for item in self.__sched_week__[x]:
                if not item[1]:
                    continue
                if item[8] > time:
                    self.__sched_week__[x].insert(pos, [WEEKDAY_LIST[x], True,
                         self.sched_str_time(time, item[8]), "Музыка",
                         "http://silver.ru/programms/muzyka/",
                         [], [], icon, time, item[8]])
                    pos = pos + 1
                time = item[9]
                pos = pos + 1
                last = item
            # Fill empty gap to 24:00
            if last[9] < 86400.0:
                self.__sched_week__[x].append([WEEKDAY_LIST[x], True,
                     self.sched_str_time(last[9], 86400.0), "Музыка",
                     "http://silver.ru/programms/muzyka/",
                     [], [], icon, last[9], 86400.0])

            # Sort again
            self.__sched_week__[x].sort(key = lambda x : (x[8], -x[1]))

        f = open(SCHED_JSON, "w")
        json.dump(self.__sched_week__, f)
        f.close()

    def sched_str_time(self, start, end):
        """ Return time in HH:MM-HH:MM """
        s_h, s_m = divmod(int(start), 3600)
        e_h, e_m = divmod(int(end), 3600)
        return "{0:0=2d}:{1:0=2d}-{2:0=2d}:{3:0=2d}".format(s_h, s_m, e_h, e_m)

    def sched_parse_time(self, str):
        """ Return time in seconds """
        try:
            x = datetime.datetime.strptime(str, "%H:%M")
        except ValueError:
            # except 24:00
            # Fuck python's floating point shit and just return the
            # right value
            return 86400.0
        d = datetime.timedelta(hours=x.hour, minutes=x.minute)
        return d.total_seconds()

### Public
    def fill_tree_strore(self, store):
        """ Fill TreeStore object """
        it = None
        sep = '\n'

        for x in range(7):
            bg_dark = False
            ch_dark = bg_dark

            for item in self.__sched_week__[x]:
                host = sep.join(item[5])
                host_url = sep.join(item[6])
                if item[1]:
                    bg_color = SCHEDULE_BG_COLORS[bg_dark]
                    fg_color = SCHEDULE_FONT_COLORS[bg_dark]
                    icon = GdkPixbuf.Pixbuf.new_from_file(item[7])
                    it = store.append(None, [item[0], item[1], item[2],
                        item[3], item[4], host, host_url, icon,
                        bg_color, fg_color])
                    ch_dark = bg_dark
                    bg_dark = not bg_dark
                else:
                    bg_color = CHILD_BG_COLORS[ch_dark]
                    fg_color = CHILD_FONT_COLORS[ch_dark]
                    icon = GdkPixbuf.Pixbuf.new_from_file_at_scale(item[7],
                                                            60, 60, True)
                    store.append(it, [item[0], item[1], item[2],
                        item[3], item[4], host, host_url, icon,
                        bg_color, fg_color])
                    ch_dark = not ch_dark

    def get_title(self):
        """ Get title of current event """
        return self.__event__[3]

    def get_icon(self):
        """ Get icon of current event """
        return GdkPixbuf.Pixbuf.new_from_file(self.__event__[7])

    def get_current(self):
        return self.__event__

    def get_next_event(self):
        """ Get next main event for today """
        for item in self.__sched_day__:
            if item[1]:
                return item
        return None

    def get_next_child(self):
        """ Get next child event for today """
        for item in self.__sched_day__:
            if not item[1]:
                return item
        return None

### Gstreamer classes
class SilverPlayer():
    """ Gstreamer container for playing network audio stream
        sophttpsrc -> decodebin -> audioconvert -> volume -> autoaudiosink"""
    def __init__(self):
        self.__playing__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__playing__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def playback_get(self):
        """ Return playback status """
        return self.__playing__

    def playback_toggle(self):
        """ Playback trigger """
        self.__playing__ = not self.__playing__
        if self.__playing__:
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def volume_get(self):
        """ Return volume """
        value = int(self.pipeline.get_by_name('volume').get_property('volume') * 100.)
        return value

    def volume_set(self, value):
        """ Set player volume [0-100] """
        self.pipeline.get_by_name('volume').set_property('volume', value / 100.)

    def volume_step(self, increase):
        """ Increase/decrease volume by 5
            Returns new value """
        value = self.pipeline.get_by_name('volume').get_property('volume')
        if increase:
            if value >= 0.95:
                value = 1.
            else:
                value = value + 0.05
        else:
            if value <= 0.05:
                value = 0.
            else:
                value = value - 0.05
        self.pipeline.get_by_name('volume').set_property('volume', value)
        return int(value * 100.)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverPlayer")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                          'source')
        self.elements["decode"] = Gst.ElementFactory.make('decodebin', 'decode')
        self.elements["convert"] = Gst.ElementFactory.make('audioconvert',
                                                           'convert')
        self.elements["volume"] = Gst.ElementFactory.make('volume', 'volume')
        self.elements["sink"] = Gst.ElementFactory.make('autoaudiosink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["volume"].set_property('volume', 1.)

        # Link elements
        def pad_added_callback(decode, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["convert"].get_static_pad('sink'))

        self.elements["decode"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"],
                                self.elements["decode"]) or \
           not Gst.Element.link(self.elements["convert"],
                                self.elements["volume"]) or \
           not Gst.Element.link(self.elements["volume"],
                                self.elements["sink"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
            self.playback_toggle()
        else:
            pass

class SilverRecorder():
    """ Gstreamer container for audio recording
        sophttpsrc -> icydemux -> filesink """
    def __init__(self):
        self.__recording__ = False
        self.create_pipeline()

    def clean(self):
        """ Free pipeline """
        self.__recording__ = False
        self.pipeline.set_state(Gst.State.NULL)

    def record_get(self):
        """ Return recorder status """
        return self.__recording__

    def record_toggle(self, name):
        """ Record trigger """
        self.__recording__ = not self.__recording__
        if self.__recording__:
            file = RECS_DIR + \
                   datetime.datetime.now().strftime("%m-%d-%y-%H:%M") + \
                   "-" + name + ".mp3"
            self.pipeline.get_by_name('sink').set_property('location', file)
            ret = self.pipeline.set_state(Gst.State.PLAYING)
        else:
            # Switch state to READY to prevent EOS
            ret = self.pipeline.set_state(Gst.State.READY)

        if ret == Gst.StateChangeReturn.FAILURE:
            logging.error("Couldn't change state")
            self.clean()
            exit(-1)

    def create_pipeline(self):
        self.pipeline = Gst.Pipeline.new("SilverRecorder")
        if not self.pipeline:
            logging.error("Couldn't create pipeline")
            exit(-1)

        # Create GStream elements
        self.elements = dict()
        self.elements["source"] = Gst.ElementFactory.make('souphttpsrc',
                                                          'source')
        self.elements["demux"] = Gst.ElementFactory.make('icydemux', 'demux')
        self.elements["sink"] = Gst.ElementFactory.make('filesink', 'sink')

        for key in self.elements.keys():
            if not self.elements[key]:
                logging.error("Couldn't create element", key)
                exit(-1)
            else:
                self.pipeline.add(self.elements[key])

        self.elements["source"].set_property('location', SILVER_STREAM_URL)
        self.elements["source"].set_property('is-live', True)
        self.elements["sink"].set_property('location', "file.mp3")

        # Link elements
        def pad_added_callback(demux, pad):
            if pad.is_linked():
                # Already linked. Skip
                return
            return pad.link(self.elements["sink"].get_static_pad('sink'))

        self.elements["demux"].connect('pad-added', pad_added_callback)

        if not Gst.Element.link(self.elements["source"],
                                self.elements["demux"]):
            logging.error("Elements could not be linked")
            exit(-1)

        # Create message bus
        msg_bus = self.pipeline.get_bus()
        msg_bus.add_signal_watch()
        msg_bus.connect('message', self.message_handler)

    def message_handler(self, bus, msg):
        struct = msg.get_structure()
        if msg.type == Gst.MessageType.ERROR:
            err, dbg = msg.parse_error()
            logging.error("Error from element %s: %s" % (msg.src.get_name(),
                                                         err))
        elif msg.type == Gst.MessageType.EOS:
            logging.warning("End of stream")
            self.clean()
        else:
            pass

class SilverGUI(Gtk.Window):
    """ GUI """
    def __init__(self, player, recorder, sched):
        self.__playing__ = False
        self.__player__ = player
        self.__recording__ = False
        self.__recorder__ = recorder
        self.__volume__ = 100
        self.__muted__ = 0

        self.__main_window__ = True
        self.__about_window__ = False
        self.__prefs_window__ = False
        self.__schedule__ = sched
        self.week_filter = datetime.date.today().strftime("%A")

        self.create_main_window()
        self.create_status_icon()
        self.notification = Notify.Notification.new("Header", "Body", "image")

### Updater
    def update_status(self):
        self.toolbar_update_label()
        self.show_notification()

### Main Window
    def create_main_window(self):
        """ Init top window """
        Gtk.Window.__init__(self, title="Silver Rain")
        self.set_border_width(0)
        self.set_default_size(650, 450)
        self.connect("delete-event", self.mw_on_delete_event)

        # Main box
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        ## Menubar
        menubar = self.create_menubar()
        vbox.pack_start(menubar, False, False, 0)
        sep = Gtk.Separator()
        vbox.pack_start(sep, False, False, 0)
        ## Schedule tree
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.NEVER,
                                   Gtk.PolicyType.AUTOMATIC)
        scrolled_window.set_min_content_height(100)
        tree = self.create_tree()
        scrolled_window.add(tree)
        vbox.pack_start(scrolled_window, True, True, 0)
        ## Selection
        selection = self.create_selection()
        vbox.pack_start(selection, False, False, 0)
        # Controls
        control_panel = self.create_control_panel()
        vbox.pack_end(control_panel, False, False, 0)

        self.add(vbox)
        self.show_all()

    def mw_on_delete_event(self, window, event):
        """ Hide top window instead of destroying it """
        self.__main_window__ = False
        window.hide()
        return True

### Selection
    def create_selection(self):
        """ Create selection buttons """
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        for day in WEEKDAY_LIST:
            button = Gtk.ToggleButton(day)
            button.connect("toggled", self.selection_on_clicked)
            hbox.pack_start(button, True, True, 0)
        return hbox

    def selection_on_clicked(self, button):
        """ Filter Treeview by selected weekday """
        self.week_filter = button.get_label()
        self.filter.refilter()

### Schedule tree
    def create_tree(self):
        """ Create schedule tree """
        store = Gtk.TreeStore(str, bool, str, str, str, str,
                              str, GdkPixbuf.Pixbuf, str, str)
        """ Store:
            0   Weekday             str
            1   IsParent            bool
            2   Time                str
            3   Title               str
            4   URL                 str
            5   Host                str
            6   Host URL            str
            7   Icon                pixbuf
            8   BackgroundColor     str
            9   FontColor           str
        """
        self.filter = store.filter_new()
        self.filter.set_visible_func(self.sched_filter_func)

        self.__schedule__.fill_tree_strore(store)

        sched_tree = Gtk.TreeView.new_with_model(self.filter)
        sched_tree.set_grid_lines(Gtk.TreeViewGridLines.HORIZONTAL)

        # Icon
        renderer = Gtk.CellRendererPixbuf()
        column = Gtk.TreeViewColumn(" ", renderer, pixbuf=7)
        renderer.set_alignment(1, 0.5)
        sched_tree.append_column(column)

        renderer = Gtk.CellRendererText()
        renderer.set_padding(10, 0)
        renderer.set_property('font', "11")
        renderer.set_alignment(0.5, 0.5)
        # Time
        column = Gtk.TreeViewColumn("Time", renderer,
                                    text=2, background=8, foreground=9)
        column.set_alignment(0.5)
        column.set_min_width(10)
        sched_tree.append_column(column)
        # Title
        renderer.set_alignment(0, 0.5)
        column = Gtk.TreeViewColumn("Title", renderer,
                                    text=3, background=8, foreground=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        # Host
        column = Gtk.TreeViewColumn("Host", renderer,
                                    text=5, background=8, foreground=9)
        column.set_alignment(0.5)
        column.set_min_width(50)
        column.set_resizable(True)
        sched_tree.append_column(column)
        return sched_tree

    def sched_filter_func(self, model, iter, data):
        """ Filter by weekday """
        return model[iter][0] == self.week_filter

### Menubar
    def create_menubar(self):
        """ Menu bar """
        agr = Gtk.AccelGroup()
        self.add_accel_group(agr)
        menubar = Gtk.MenuBar()
        # Music
        music_menu = Gtk.Menu()
        music = Gtk.MenuItem("Music")
        music.set_submenu(music_menu)
        ## Play
        self.menubar_play = self.create_menuitem("Play", "media-playback-start")
        self.menubar_play.set_size_request(90, -1)
        self.menubar_play.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F6")
        self.menubar_play.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop
        self.menubar_stop = self.create_menuitem("Stop", "media-playback-stop")
        self.menubar_stop.set_sensitive(False)
        self.menubar_stop.connect("activate", self.playback_toggle)
        key, mod = Gtk.accelerator_parse("F7")
        self.menubar_stop.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Record
        self.menubar_record = self.create_menuitem("Record", "media-record")
        self.menubar_record.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F8")
        self.menubar_record.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Stop recording
        self.menubar_stop_recording = self.create_menuitem("Stop recording",
                                          "media-playback-stop")
        self.menubar_stop_recording.set_sensitive(False)
        self.menubar_stop_recording.connect("activate", self.record_toggle)
        key, mod = Gtk.accelerator_parse("F9")
        self.menubar_stop_recording.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Mute
        self.menubar_mute = Gtk.CheckMenuItem("Mute")
        self.menubar_mute.connect("toggled", self.mute_toggle)
        key, mod = Gtk.accelerator_parse("<Control>M")
        self.menubar_mute.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Preferences
        prefs = self.create_menuitem("Preferences", "gtk-preferences")
        prefs.connect("activate", self.create_prefs_window)
        key, mod = Gtk.accelerator_parse("<Control>P")
        prefs.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)
        ## Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        key, mod = Gtk.accelerator_parse("<Control>Q")
        quit.add_accelerator("activate", agr,
                                          key, mod, Gtk.AccelFlags.VISIBLE)

        ## Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [self.menubar_play, self.menubar_stop,
                     self.menubar_record, self.menubar_stop_recording,
                     sep[0], self.menubar_mute, sep[1], prefs, sep[2], quit]:
            music_menu.append(item)

        # Help
        help_menu = Gtk.Menu()
        help = Gtk.MenuItem("Help")
        help.set_submenu(help_menu)
        ## About
        about = self.create_menuitem("About", "gtk-about")
        about.set_size_request(90, -1)
        about.connect("activate", self.create_about_window)
        key, mod = Gtk.accelerator_parse("F1")
        about.add_accelerator("activate", agr, key, mod, Gtk.AccelFlags.VISIBLE)
        help_menu.append(about)

        menubar.append(music)
        menubar.append(help)
        return menubar

    def menubar_mute_toggle(self):
        if self.__muted__:
            self.menubar_mute.set_active(False)
        else:
            self.menubar_mute.set_active(True)

### Toolbar
    def create_control_panel(self):
        """ Playback control buttons """
        toolbar = Gtk.Toolbar()
        toolbar.set_orientation(Gtk.Orientation.HORIZONTAL)
        toolbar.set_style(Gtk.ToolbarStyle.ICONS)

        control_panel = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        control_panel.set_spacing(6)
        control_panel.set_border_width(6)
        ## Playback Button
        icon = self.get_playback_label()[1]
        self.playback_button = self.create_toolbutton(icon)
        self.playback_button.connect("clicked", self.playback_toggle)
        ## Record Button
        icon = self.get_record_label()[1]
        self.record_button = self.create_toolbutton(icon)
        self.record_button.connect("clicked", self.record_toggle)
        self.record_button.focus_on_click = True
        ## Label
        self.text = Gtk.Label()
        self.text.set_selectable(True)
        self.text.set_yalign(0.45)
        self.toolbar_update_label()
        ## Mute Button
        icon = self.get_volume_icon()
        self.mute_button = self.create_toolbutton(icon)
        self.mute_button.connect("clicked", self.cp_on_mute)

        toolbar.insert(self.playback_button, 0)
        toolbar.insert(self.record_button, 1)
        ## Volume scale
        ad = Gtk.Adjustment(value=self.__volume__, lower=0,
                            upper=100, step_increment=5,
                            page_increment=10, page_size=0)
        self.volume = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL,
                                adjustment=ad)
        self.volume.set_property('draw-value', False)
        self.volume.connect("value-changed", self.cp_on_volume_changed)
        self.volume.set_size_request(80, 0)

        control_panel.pack_start(toolbar, False, False, 0)
        control_panel.pack_start(self.text, True, False, 0)
        control_panel.pack_end(self.volume, False, False, 0)
        control_panel.pack_end(self.mute_button, False, False, 0)
        return control_panel

    def toolbar_update_label(self):
        self.text.set_text("<span size='12000'><b>" +
                self.__schedule__.get_title() + "</b></span>")
        self.text.set_use_markup(True)

    def cp_on_volume_changed(self, scale):
        self.__volume__ = scale.get_value()
        if not self.__muted__ and self.__volume__ == 0:
            self.menubar_mute_toggle()
        if self.__muted__ and self.__volume__ > 0:
            self.__muted__ = self.__volume__
            self.menubar_mute_toggle()
        self.__player__.volume_set(self.__volume__)

    def cp_on_mute(self, arg):
        self.menubar_mute_toggle()

    def create_toolbutton(self, icon):
        ## Playback Button
        button = Gtk.ToolButton()
        button.set_icon_name(icon)
        button.focus_on_click = False
        return button

### Popup menu
    def create_popup_menu(self, icon, button, time):
        """ Show menu on right click """
        self.popup_menu = Gtk.Menu()
        # Playback
        text, icon = self.get_playback_label()
        play = self.create_menuitem(text, icon)
        play.connect("activate", self.playback_toggle)
        play.set_size_request(100, -1)
        # Record
        text, icon = self.get_record_label()
        record = self.create_menuitem(text, icon)
        record.connect("activate", self.record_toggle)
        # Mute
        mute = Gtk.CheckMenuItem("Mute")
        if self.__muted__:
            mute.set_active(True)
        mute.connect("toggled", self.popup_mute)
        # Preferences
        preferences = self.create_menuitem("Preferences", "gtk-preferences")
        preferences.connect("activate", self.create_prefs_window)
        # Quit
        quit = self.create_menuitem("Quit", "gtk-quit")
        quit.connect("activate", Gtk.main_quit)
        # Separator
        sep = []
        for i in range(3):
            sep.append(Gtk.SeparatorMenuItem())

        for item in [play, record, sep[0], mute,
                     sep[1], preferences, sep[2], quit]:
            self.popup_menu.append(item)
        self.popup_menu.show_all()

        def pos_func(menu, x, y, icon):
            return (Gtk.StatusIcon.position_menu(menu, x, y, icon))
        self.popup_menu.popup(None, None, pos_func,
                              self.status_icon, button, time)

    def popup_mute(self, arg):
        self.menubar_mute_toggle()

### Status Icon
    def create_status_icon(self):
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_from_icon_name("media-tape")
        self.status_icon.connect("activate", self.status_icon_on_activate)
        self.status_icon.connect("popup-menu", self.create_popup_menu)
        self.status_icon.connect("scroll-event", self.status_icon_on_scroll)

    def status_icon_on_activate(self, icon):
        """ Show/hide main window on left click """
        self.__main_window__ = not self.__main_window__
        if self.__main_window__:
            self.show()
        else:
            self.hide()

    def status_icon_on_scroll(self, icon, data):
        """ Change volume by scrolling on status icon """
        direction = data.direction
        if direction == Gdk.ScrollDirection.UP:
            self.__volume__ = self.__player__.volume_step(True)
            if self.__muted__:
                self.menubar_mute_toggle()
        elif direction == Gdk.ScrollDirection.DOWN:
            self.__volume__ = self.__player__.volume_step(False)
            if self.__volume__ == 0:
                self.menubar_mute_toggle()
        self.volume.set_value(self.__volume__)

### Preferences window
    def create_prefs_window(self, something):
        pass

### About window
    def create_about_window(self, icon):
        def uri_open(uri):
            Popen(['xdg-open', uri], stdout=PIPE)
        about = Gtk.AboutDialog()
        about.set_name("Silver Rain")
        about.set_version("0.1")
        about.set_copyright('Copyright \xa9 2015 Petr Skovoroda')
        about.set_comments('Silver Rain radio player')
        about.set_website('http://silver.ru')
        about.run()
        about.destroy()

### Common
    def create_menuitem(self, text, icon):
        """ Create Menu item with icon """
        icontheme = Gtk.IconTheme.get_default()
        icon = icontheme.load_icon(icon, 16, 0)
        img = Gtk.Image()
        img.set_from_pixbuf(icon)

        menuitem = Gtk.ImageMenuItem()
        menuitem.set_image(img)
        menuitem.set_label(text)
        return menuitem

    def playback_toggle(self, button):
        self.__playing__ = not self.__playing__
        self.playback_button.set_icon_name(self.get_playback_label()[1])

        if self.__playing__:
            self.menubar_play.set_sensitive(False)
            self.menubar_stop.set_sensitive(True)
        else:
            self.menubar_play.set_sensitive(True)
            self.menubar_stop.set_sensitive(False)

        self.__player__.playback_toggle()
        self.show_notification()

    def record_toggle(self, button):
        self.__recording__ = not self.__recording__
        self.record_button.set_icon_name(self.get_record_label()[1])
        if self.__recording__:
            self.menubar_record.set_sensitive(False)
            self.menubar_stop_recording.set_sensitive(True)
        else:
            self.menubar_record.set_sensitive(True)
            self.menubar_stop_recording.set_sensitive(False)

        name = self.__schedule__.get_title()
        self.__recorder__.record_toggle(name)

    def mute_toggle(self, button, val=0):
        if self.__muted__:
            self.__volume__ = self.__muted__
            self.__muted__ = 0
        else:
            self.__muted__ = self.__volume__ or 5
            self.__volume__ = 0

        self.__player__.volume_set(self.__volume__)
        self.mute_button.set_icon_name(self.get_volume_icon())
        self.volume.set_value(self.__volume__)

    def get_playback_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__playing__:
            label = "Play"
            icon = "media-playback-start"
        else:
            label = "Stop"
            icon = "media-playback-stop"
        return label, icon

    def get_record_label(self):
        """ Return label and icon for Playback menu/button """
        if not self.__recording__:
            label = "Record"
            icon = "media-record"
        else:
            label = "Stop recording"
            icon = "media-playback-stop"
        return label, icon

    def get_volume_icon(self):
        """ Return label and icon for Playback menu/button """
        if self.__muted__:
            icon = "audio-volume-muted"
        else:
            icon = "audio-volume-high"
        return icon

    def show_notification(self):
        if self.__playing__:
            text = "Silver Rain"
            body = self.__schedule__.get_title()
            self.notification.set_icon_from_pixbuf(self.__schedule__.get_icon())
            self.notification.update(text, body)
        else:
            text = "Silver Rain"
            body = "Stopped"
            img = "notification-audio-stop"
            self.notification.update(text, body, img)
        self.notification.show()

### Boom, baby
GObject.threads_init()
Gst.init(None)
signal.signal(signal.SIGINT, signal.SIG_DFL)
Notify.init("Silver Rain")
# Create directories if they don't exist
for dir in [APP_DIR, IMG_DIR, RECS_DIR]:
    if not os.path.exists(dir):
        os.makedirs(dir)
# Init
player = SilverPlayer()
recorder = SilverRecorder()
sched = SilverSchedule()
silver = SilverGUI(player, recorder, sched)
timer = SilverTimer(sched, silver)
# Main loop
Gtk.main()
# Cleanup
Notify.uninit()
player.clean()
recorder.clean()
timer.clean()
